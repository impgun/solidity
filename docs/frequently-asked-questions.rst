########################
Часто задаваемые вопросы
########################

Этот список был первоначально составлен [fivedogit](mailto:fivedogit@gmail.com).


***************
Базовые вопросы
***************

Что такое Solidity?
=============================

Solidity - это созданный в DEV (т. е. Ethereum Foundation) вдохновленный Javascript язык, который можно использовать для создания с март-контрактов на блокчейне Эфириума. Есть и другие языки, которые можно использовать (LLL, Serpent и не только). Главные аргументы в пользу Solidity - это то, что он статически типизирован и предлагает много передовых возможностей, таких как наследование, библиотеки, сложные пользовательские типы и оптимизатор байт-кода.

Контракты Solidity можно компилировать несколькими разными способами (см. ниже), и результирующий вывод можно вырезать/вставлять в консоль geth для их развертывания на блокчейне Эфириума.

Доступны некоторые `примеры контрактов <https://github.com/fivedogit/solidity-baby-steps/tree/master/contracts/>`_ by fivedogit и здесь должен быть `тестовый контракт <https://github.com/ethereum/solidity/blob/develop/test/libsolidity/SolidityEndToEndTest.cpp>`_ для каждой возможности Solidity.

Как скомпилировать контракт?
============================

Пожалуй, скорейший способ - это воспользоваться `онлайн-компилятором <https://chriseth.github.io/browser-solidity/>`_.

Вы также можете использовать двоичный файл `solc`, который поставляется вместе с cpp-ethereum, для компиляции контрактов, или emerging option - это использовать Mix, интегрированную среду разработки.


Создание и публикация простейшего контракта
===========================================

Совсем простой контракт вот: `greeter <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/05_greeter.sol>`_

Можно ли сделать что-то при конкретном номере блока (например, опубликовать контракт или выполнить транзакцию)?
===============================================================================================================

Нет никакой гарантии, что транзакция случится в следующем или каком-либо будущем конкретном блоке, поскольку включют транзакции в блокчейн майнеры, а не ее отправитель. Это относится к вызовам функций/транзакциям и транзакциям создания контрактов.

Если вы хотите запланировать будущие вызовы своего контракта, можете использовать `alarm clock <http://www.ethereum-alarm-clock.com/>`_.

Что такое "полезная нагрузка" транзакции?
=========================================

Это просто "данные" в байт-коде, отправляемые вместе с запросом.

Доступен ли декомпилятор?
=========================

Декомпилятора в Solidity нет. В принципе, это в некоторой степени возможно, но, например, имена переменных будут утрачены, и потребуется немало усилий, чтобы сделать его похожим на оригинальный исходный код.

Байт-код можно декомпилировать в опкоды, и этот сервис предоставляют несколько блокчейн-эксплореров.

Контрактам следует публиковать на блокчейне свй первоначальный исходный код, если предполагается, что их будут использовать третьи стороны.

Освобождает ли функция selfdestruct() место в блокчейне?
========================================================

Она удаляет байт-код контракта и хранилище из текущего блока и в дальнейшее будущее, но, поскольку блокчейн хранит каждый блок (т. е. всю историю), на деле это не освободит место в полных/архивных узлах.

Создание контракта, который можно убить и вернуть фонды
=======================================================

Прежде всего, предупреждение: убийство контрактов кажется хорошей идеей, потому что "очистка" - это всегда хорошо, но, как сказано выше, на самом деле это не очистка. Более того, если эфир отправляется удаленным контрактам, он будет безвозвратно утерян.

Если вы хотите деактивировать свои контракты, лучше **отключите** их, изменив какое-нибудь внутреннее состояние, чтобы все функции throw. Это сделает невозможным использование контракта, и эфир, отправляемый контракту, автоматически будет возвращаться.

Теперь ответ на вопрос. Внутри конструктора создателем является `msg.sender`. Сохраните ее. Затем вызовите `selfdestruct(creator);`, чтобы убить и вернуть фонды.

`example <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/05_greeter.sol>`_

Имейте в виду, что, если вы `import "mortal"` в начале контрактов и объявляете `contract SomeContract is mortal { ...` и компилируете с компилятором, который уже имеет это (что включает `browser-solidity <https://chriseth.github.io/browser-solidity/>`_), то `kill()` выполняется за вас. Как только контракт "mortal", вы можете вызвать `contractname.kill.sendTransaction({from:eth.coinbase})`, точно так же, как в моих примерах.

Сохранение эфира в контракте
============================

Хитрость в том, чтобы создать контракт с помощью кода `{from:someaddress, value: web3.toWei(3,"ether")...}`

См. `endowment_retriever.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/30_endowment_retriever.sol>`_.

Использование неконстантной функции (req sendTransaction) для увеличения переменной в контракте
===============================================================================================

См. `value_incrementer.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/20_value_incrementer.sol>`_.

Получение адреса контракта в Solidity
=====================================

Краткий ответ: адрес контракта представляет глобальная переменная `this`.

См. `basic_info_getter <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/15_basic_info_getter.sol>`_.

Подробный ответ: переменная `this` представляет текущий контракт. Ее типом является тип контракта. Поскольку любой тип контракта, по сути, наследуется от типа `address`, `this` всегда можно преобразовать в `address`, и в этом случае она содержит собственный адрес.

Каковы различия функции, отмеченной constant, и обычной?
========================================================

Функции `constant` могут выполнять некоторое действие и возвращать значение, но не могут изменять состояние (это еще не форсируется компилятором). Иначе говоря, константная функция не может сохранять или обновлять какие-либо переменные в контракте или более широком блокчейне. Эти функции вызываются в виде `c.someFunction(...)` из geth или любой другой среды web3.js.

"non-constant" функции (те, у которых нет спецификатора `constant`) необходимо вызывать в формате `c.someMethod.sendTransaction({from:eth.accounts[x], gas: 1000000});`. Иначе говоря, поскольку они могут изменять состояние, с ними нужно отправлять газ как плату за выполнение работы.

Как сделать, чтобы контракт вернул вам свои фонды (не используя selfdestruct(...)). 
========================================================================

Этот пример демонстрирует, как отправить фонды из контракта адресу. 

См. `endowment_retriever <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/30_endowment_retriever.sol>`_.

Что такое отображение и как его использовать?
=============================================

Отображение очень похоже на K->V hashmap. Если у вас есть переменная состояния типа `mapping (string -> uint) x;`, то вы можете получать доступ этому значению как `x["somekeystring"]`.

Как получить длину отображения?
===============================

Отображения - это довольно низкоуровневая структура данных. Она не хранит ключи, и невозможно узнать, какие или сколько значений "задано". На самом деле заданы по умолчанию все значения всех возможных ключей, просто они инициализированы нулями.

В этом смысле атрибут `length` на самом деле не применим к отображению.

Если вы хотите использовать "sized mapping", вы можете использовать итерируемое отображение (см. ниже) или просто динамический массив структур.

Являются ли отображения итерируемыми?
=====================================

Отображения сами по себе не итерируемы, но вы можете использовать поверх нее структуру данных более высокого уровня, например `iterable mapping <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>`_.

Можно ли возвратить из вызова функции Solidity массив или строку?
=================================================================

Да. См. `array_receiver_and_returner.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/60_array_receiver_and_returner.sol>`_.

Однако из **вызванной внутри Solidity** функции проблематично вернуть любые данные переменного размера (например, массив переменного размера, такой как `uint[]`). Это ограничение EVM, которое будет устранено в следующем обновлении протокола.

Возвращать данные переменного размера как часть внешней транзакции или вызова можно без проблем.

Как представить в Solidity значение double/float?
=================================================

Это пока невозможно.

Можно ли инициализировать массив со встраиванием: string[] myarray = ["a", "b"];
=======================================================================================

Да. Однако следует отметить, что в настоящее время это работает только с массивами в памяти статического размера. Вы даже можете создать встроенный массив в памяти в операторе return. Здорово, да?

Пример::

    contract C {
        function f() returns (uint8[5]) {
            string[4] memory AdaArr = ["This", "is", "an", "array"];
            return ([1, 2, 3, 4, 5]);
        }
    }

Что такое события и зачем они нужны?
====================================

Предположим, что вам нужен контракт, уведомляющий внешний мир о том, когда что-то происходит. Контракт может сгенерировать событие, которое можно слушать из web3 (в geth или веб-приложении). Главное преимущество событий в том, что они хранятся на блокчейне специальным образом, так что их очень легко искать.

Каковы разные видимости функций?
================================

Спецификаторы видимости изменяют не только видимость, но и возможные способы вызова функций. В общем, функции в одном контракте могут также вызываться внутренне (что дешевле и позволяет типы памяти передавать по ссылке). Это выполняется, если вы просто используете `f(1,2)`. Если вы используете `this.f(1,2)` или `otherContract.f(1,2)`, функция вызывается внешне.

Внутренние вызовы функций имеют то преимущество, что вы можете использовать в качестве параметров все типы Solidity, но в случае внешних вызовов вынуждены ограничиваться более простыми типами ABI.

* external: все, только внешне

* public: все (это вариант по умолчанию), внешне и внутренне

* internal: только этот контракт и контракты, производные от него, только внутренне

* private: только этот контракт, только внутренне


Должны ли конструкторы контрактов быть publicly visible?
=====================================================

Вы можете использовать спецификаторы видимости, но они еще не имеют никакого эффекта. Как только код контракта развернут, конструктор из него удаляется.

Может ли контракт иметь несколько конструкторов?
================================================

Нет, у контракта может быть только один конструктор.

Говоря точнее, у него может быть только одна функция, имя которой совпадает с именем конструктора.

Нааличие нескольких конструкторов, различающихся по количеству аргументов или их типами), допускаемое в других языках, в Solidity не поддерживается.

Конструктор необходим?
======================

Нет. Если конструктора нет, будет использован generic one без аргументов и действий.

Надежны ли временные метки (now, block.timestamp)? 
==================================================

Это зависит от того, что понимать под "надежностью". В общем, они предоставляются майнерами, а потому уязвимы.

Если только кто-то не балует с блокчейном по-настоящему или не случилось что-то с часами на вашем компьютере, вы можете исходить из следующих предположений:

Вы публикуете транзакцию в момент X, эта транзакция содержит тот же код, который вызывает `now` и включается в блок с временной меткой Y, и этот блок включается в каноническй блокчейн (публикуется) в момент Z.

Значение `now` будет равно Y, и X <= Y <= Z.

Никогда не используйте `now` или `block.hash` как источник случайности, если не уверены в том, что делаете!

Может ли функция контракта возвращать структуру?
================================================

Да, но только во "внутренних" вызовах функций.

Если я возвращаю перечисление, я получаю только целочисленные значения в web3.js. Как получить именованные значения?
====================================================================================================================

Перечисления не поддерживаются в ABI, они просто поддерживаются в Solidity. Вы должны пока что сделать для себя отображение, мы можем позже предоставить некоторую помощь.

Что такое с "function () { ... }" внутри контрактов Solidity? Как функция может не иметь имени?
===============================================================================================

Эта функция называется "fallback function" и вызывается, когда кто-то просто отправляет эфир контракту, не предоставляя никаких данных, или если кто-то напутал с типами и пытается вызвать функцию, которой не существует.

Поведение по умолчанию (если никакая fallback function не задана явно) в этих ситуациях - это просто принмать вызов и ничего не делатль. Это желательно во многих случаях, но следует использовать, только если есть способ вывести эфир из контракта.

Если контракт не рассчитан на получение эфира в простых трансферах, вам следует реализовать fallback function как

`function() { throw; }`

это приведет к обращению всех транзакций этому контракту, которые не вызывают существующую функцию, чтобы весь эфир отправить обратно.

Другой способ использования аварийной функции - это, например, регистрация с помощью события того, что ваш контракт получил эфир.

*Внимание*: если вы реализуете аварийную функцию, позаботьтесь о том, чтобы она использовала как можно меньше газа, потому что `send()` предоставит лишь ограниченный объем.

Можно ли передавать аргументы в аварийную функцию?
==========================================================

Аварийная функция не может принимать параметры.

В некоторых обстоятельствах вы может отправлять данные. Если вы позаботитесь о том, чтобы никакие другие функции не вызывались, вы можете получить доступ к данным с помощью кода `msg.data`.

Можно ли инициализировать переменные состояния встроенным кодом?
================================================================

Да, это возможно для всех типов (даже для структур). Однако следует отметить, что в случае массивов вы должны объявить их как статические массивы в памяти.

Примеры::

    contract C {
        struct S { uint a; uint b; }
        S public x = S(1, 2);
        string name = "Ada";
        string[4] memory AdaArr = ["This", "is", "an", "array"];  
    }
    contract D {
        C c = new C();
    }

Что такое ключевое слово "modifier"?
===============================

Модификаторы - это способ добавления кода к функции для добавления guards, инициализации или очистки in a concise way.

Примеры см. в `features.sol <https://github.com/ethereum/dapp-bin/blob/master/library/features.sol>`_.

Как работают структуры?
=======================

См. `struct_and_for_loop_tester.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/65_struct_and_for_loop_tester.sol>`_.

Как работают циклы for?
=======================

Очень похоже на JavaScript. Следует, однако, иметь в виду один момент.

Если вы используете код `for (var i = 0; i < a.length; i ++) { a[i] = i; }`, то тип `i` будет выведен только из `0`, которое имеет тип `uint8`. Это означает, что, если `a` имеет больше `255` элементов, ваш цикл не завершится, потому что `i` может содержать только значения до `255`.

Лучше использовать код `for (uint i = 0; i < a.length...`

См. `struct_and_for_loop_tester.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/65_struct_and_for_loop_tester.sol>`_.

Какой набор знаков используется в Solidity?
===========================================

Solidity безразличен к набору знаков в отношении строк в исходном коде, хотя рекомендуется использовать utf-8. В идентификаторах (переменных, функциях, ...) можно использовать только ASCII.

Каковы некоторые примеры простых операций над строками (substring, indexOf, charAt, ...)?
=========================================================================================

Некоторые функции для работы со строками доступны в файле `stringUtils.sol <https://github.com/ethereum/dapp-bin/blob/master/library/stringUtils.sol>`_, что будет расширено в будущем.

Пока что, если вы хотите изменить строку (даже если вы хотите лишь узнать ее длину), вам всегда следует преобразовывать ее сначала в `bytes`::

    contract C {
        string s;
        function append(byte c) {
            bytes(s).push(c);
        }
        function set(uint i, byte c) {
            bytes(s)[i] = c;
        }
    }


Можно ли объединить две строки (выполнить конкатенацию)?
========================================================

Пока что вы должны делать это вручную.

Почему низкоуровневый function .call() менее предпочтителен, чем создание экземпляра контракта с переменной (ContractB b;) и выполнение его функций (b.doSomething();)?
=================================================================================================================================================================

Если вы используте фактические функции, компилятор будет сообщать вам, если типы ваших аргументов не соответствуют, если функция не существует или не видима, и это обеспечит упаковку аргументов для вас.

См. `ping.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_ping.sol>`_ и
`pong.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_pong.sol>`_.

Неиспользованный газ автоматически возвращается?
================================================

Да, и это происходит немедленно, т. е. как часть транзакции.

При возврате значения, скажем, типа "uint" можно ли возвратить значение "undefined" или "null"-like?
========================================================================================================

Это невозможно, потому что все типы используют полный диапазон значений.

У вас есть вариант `throw` при ошибке, что также обратит всю транзакцию, что может быть хорошей идеей, если вы попали в непредвиденную ситуацию.

Если вы не хотите throw, вы можете возвратить пару::

    contract C {
        uint[] counters;
        function getCounter(uint index)
            returns (uint counter, bool error) {
                if (index >= counters.length) return (0, true);
                else return (counters[index], false);
            }
        function checkCounter(uint index) {
            var (counter, error) = getCounter(index);
            if (error) { ... }
            else { ... }
        }
    }


Включаются ли комментарии в развернутые контракты и увеличивают ли они расходы газа на развертывание?
==================================================================================

Нет, все, что не требуется для выполнения, удаляется во время компиляции. Это включает, помимо прочего, комментарии, имена переменных и имена типов.

Что случится, если отправить контракту эфир вместе с вызовом функции?
========================================================================

Он добавляется к общему балансу контракта, как и тогда, когда вы отправляете эфир при создании контракта.

Можно ли получить квитанцию транзакции, выполненной между контрактами?
===================================================================================

Нет, вызов функции одного контракта из другого не приводит к созданию собственной транзакции, вам нужно смотреть в общей транзакции. Именно по этой причине несколько блокчейн-эксплореров не отображают правильно эфир, отправленный между контрактами.

Что такое ключевое слово memory? Что оно делает?
============================================

Виртуальная машина Эфириума может хранить элементы в трех областях.

Первая - "хранилище", где находятся все переменные состояния контракта. У каждого контракта есть свое хранилище, и оно сохраняется между функциями вызовов и довольно дорого в использовании.

Второе - "память", которое используется дял хранения временных значений. Оно очищается между (внешними) вызовами функций и дешево.

Третий - "стек", который используется для хранения небольших локальных переменных. Он почти бесплатен в использовании, но может содержать ограниченное количество значений.

Почти ни для каких типов вы не можете указать, где они должны храниться, потому что они копируются каждый раз, когда используются.

К типам, где важно так называемое расположение хранилища, относятся структуры и массивы. Если вы, например, передаете такие переменные в вызовах функций, их данные не копируются, если они могут остаться в памяти или в хранилище. Это означает, что вы можете изменить их содержимое в вызванной функции, и эти изменения будут видны в вызвавшем коде. У расположения хранилища есть настройки по умолчанию, зависящие от типа переменной:

* переменные состояния всегда находятся в хранилище
* аргументы функций всегда находятся в памяти
* локальные переменные всегда ссылаются на хранилище

Пример::

    contract C {
        uint[] data1;
        uint[] data2;
        function appendOne() {
            append(data1);
        }
        function appendTwo() {
            append(data2);
        }
        function append(uint[] storage d) {
            d.push(1);
        }
    }

Функция `append` может работать и с `data1`, и с `data2`, и ее модификации будут сохраняться перманентно. Если удалить ключевое слово `storage`, по умолчанию для аргументов функций будет использоваться `memory`. Это имеет тот эффект, что в точке, где вызывается `append(data1)` или `append(data2)` в памяти создается независимая копия переменной состояния, и функция `append` работает с этой копией (которая не поддерживает `.push` - но это другой разговор). Изменения этой независимой копии не переносятся на `data1` или `data2`.

Частая ошибка - объявлять локальную переменную в предположении, что она будет создана в памяти, хотя на самом деле она будет создана в хранилище::

    /// ЭТОТ КОНТРАКТ СОДЕРЖИТ ОШИБКУ
    contract C {
        uint someVariable;
        uint[] data;
        function f() {
            uint[] x;
            x.push(2);
            data = x;
        }
    }

Локальная переменная `x` имеет тип `uint[] storage`, но, поскольку хранилище не выделяется динамически, оно должно быть назначено из переменной состояния, прежде чем его можно будет использовать. Таким образом, для `x` не выделяется никакое место в хранилище, но вместо этого она работает исключительно как псевдоним существующей переменной в хранилище.

Что произойдет, так это то, что компилятор интерпретирует `x` как указатель на хранилище и укажет им по умолчанию на слот хранилища `0`. Это имеет тот эффект, что `someVariable` (которая находится в слоте хранилища `0`) изменяется кодом `x.push(2)`.

Вот правильный способ сделать это::

    contract C {
        uint someVariable;
        uint[] data;
        function f() {
            uint[] x = data;
            x.push(2);
        }
    }

Может ли обычный счет (т. е. не контракта) Эфириума быть навсегда закрыт как контракт?
=============================================================================================

Нет. Счета не контрактов "существуют", пока его закрытый ключ кому-то известен или может быть некоторым образом сгенерирован.

В чем разница между `bytes` и `byte[]`?
====================================================

`bytes` обычно эффективнее: при использовании в качестве аргументов функций (т. е. в CALLDATA) или в памяти каждый элемент `byte[]` дополняется до 32 байтов, при этом впустую расходуется 31 байт на элемент.

Можно ли отправить значение при вызове перегруженной функции?
====================================================================

Это известная нехватающая возможность. https://www.pivotaltracker.com/story/show/92020468
as part of https://www.pivotaltracker.com/n/projects/1189488

В настоящее время лучшее решение - это ввести специальный случай для газа и значения и просто перепроверять, имеются ли они, в точке разрешения перегруженной функции.


******************
Продвинутые вопросы
******************

Как получить случайное число в контракте? (Для реализации самоисполняемого гемблинг-контракта.)
=============================================================================================

Получить правильно случайность - часто ключевая часть криптопроекта, и большинство неудач являются результатом плохих генераторов случайных чисел.

Если вам не нужна надежная защита, можете создать что-то вроде `coin flipper <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/35_coin_flipper.sol>`_, но в противном случае лучше используте контракт, предоставляющий случайность, такой как `RANDAO <https://github.com/randao/randao>`_.

Получение возвращаемого значения из неконстантной функции из другого контракта
==============================================================================

Ключевой момент в том, что вызывающий контракт должен знать о функции, которую он намеревается вызвать.

См. `ping.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_ping.sol>`_
и `pong.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_pong.sol>`_.

Указание контракту сделать что-то при его майнинге в первый раз
===============================================================

Используйте конструктор. Все внутри него будет выполнено при первом майнинге контракта.

См. `replicator.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/50_replicator.sol>`_.

Может ли контракт создать другой контракт?
=======================================

Да, см. `replicator.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/50_replicator.sol>`_.

Имейте в виду, что полный код создаваемого контракта нужно включить в контракт-создатель. Это также означает, что циклическое создание невозможно (потому что контракт должен был бы содержать собственный код) - по крайней мере, не обычым способом.

Как создать двумерный массив?
=======================================

См. `2D_array.sol <https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/55_2D_array.sol>`_.

Имейте в виду, что на заполнение квадрата 10x10 значениями `uint8` + создание контракта потребовалось на день написания этого текста более `800 000` газа. На 17x17 - `2000 000` газа. С ограничением в 3,14 миллиона... ну, это довольно низкий потолок того, что вы можете создать пока.

Имейте в виду, что простое "создание" массива бесплатно, затраты связаны с его заполнением.

Note2: Оптимизация доступа к хранилищу может существенно сократить траты газа, потому что 32 значения `uint8` можно хранить в одном слоте. проблема в том, что эти оптимизации в настоящее время не работают между циклами и также имеют проблему с проверко границ. Таким образом, в будущем вы можете получить результаты гораздо лучше.

Что делает код p.recipient.call.value(p.amount)(p.data)?
======================================================

Каждый внешний вызов функции в Solidity можно модифицировать двумя способами:

1. Вы можете добавить эфир вместе с вызовом
2. Вы можете ограничить объем газа, доступный вызову

Это выполняется путем "вызова функции на функции":

`f.gas(2).value(20)()` вызывает модифицированную функцию `f` и тем самым отправляя 20 Wei и ограничивая газ значением 2 (так что этот вызов функции, скорее всего, исчерпает газ и возвратит ваши 20 Wei).

В приведенном выше примере для вызова другого контракта используется низкоуровневая функция `call` с полезной нагрузкой `p.data`, и вместе с этим вызовом отправляется `p.amount` Wei.

Может ли функция контракта принимать двумерный массив?
=======================================================

Это еще не реализовано для внешних вызовов и динамических массивов - вы можете использовать только одноуровневые динамические массивы

Каково отношение между типами bytes32 и string? Почему ‘bytes32 somevar = "stringliteral";’ работает и что значит сохраненное 32-разрядное шестнадцатеричное значение?
==============================================================================================================================================================

Тип `bytes32` может содержать 32 (необработанных) байта. В присваивании `bytes32 samevar = "stringliteral";` строковый литерал интерпретируется в своей необработанной байтовой форме, и, если вы посмотрите `somevar` и увидите 32-разрядное шестнадцатеричное значение, это просто `"stringliteral"` в шестнадцатеричной системе счисления.

Тип `bytes` похож, только он может изменять длину.

Наконец, `string`, по сути, идентичен `bytes`, только предполагается, что он содержит реальную строку в кодировке utf-8. Поскольку `string` хранит данные в кодировке utf-8, вычислять количество знаков в строке довольно дорого (кодировка некоторых знаков занимает больше одного байта). По этой причине `string s; s.length` пока не поддерживается; даже индексный доступ `s[2]` не поддерживается. Но если вам нужен доступ к строке в низкоуровневой байтовой кодировке, вы можете использовать `bytes(s).length` и `bytes(s)[2]`, которые возвратят количество байтов в кодировке utf-8 строки (а не количество знаков) и второй байт (не знак) строки в кодировке utf-8 соответственно.


Может ли контракт передать массив (статического размера) или строку или bytes (динамического размера) другому контракту?
=================================================================================================

Конечно. Имейте в виду, что, если вы пересечете "границу" между памятью и хранилищем, будут созданы независимые копии::

    contract C {
      uint[20] x;
      function f() {
        g(x);
        h(x);
      }
      function g(uint[20] y) {
        y[2] = 3;
      }
      function h(uint[20] storage y) {
        y[3] = 4;
      }

Вызов `g(x)` не окажет влияния на `x`, потому что он должен создать независимую копию значения из хранилища в памяти (по умолчанию расположением хранилища является память). С другой стороны, `h(x)` успешно модифицирует `x`, потому что передается только ссылка, а не копия.

Иногда когда я пытаюсь изменить длину массива кодом вроде: "arrayname.length = 7;" компилятор сообщает об ошибке "Value must be an lvalue". Почему?
==============================================================================================================================================

Вы можете изменять размеры динамического массива в хранилище (т. е. массива, объявленного на уровне контракта) с помощью кода `arrayname.length = <some new length>;`. Если вы получите ошибку "lvalue", вы, вероятно, делаете неправильно одно из двух.

1. Пытаетесь изменить размеры массива "в памяти" или

2. Пытаетесь изменить размеры нединамического массива.

::

    int8[] memory memArr;       // случай 1
    memArr.length++;            // недопустимо
    int8[5] storageArr;         // случай 2
    somearray.length++;         // допустимо
    int8[5] storage storageArr2; // явный случай 2
    somearray2.length++;         // допустимо

**Важное примечание:** В Solidity измерения массива объявляются обратно способу, к которому вы, возможно, привыкли в объявлениях на C или Java, но доступ к ним выполняется как в C и Java.

Например, `int8[][5] somearray;` - это 5 динамических массивов `int8`.

Причина этого в том, что `T[5]` - всегда массив из 5 `T` независимо от того, является ли сам `T` массивом или нет (в C и Java это не так).

Можно ли возвратить из функции Solidity массив строк ( string[] )?
===================================================================================

Пока нет, поскольку для этого требуется двухуровневый динамический массив (сама `string` - это динамический массив).

При вызове массива можно ли получить весь массив? Или для этого нужно писать функцию-хелп***ер?
===========================================================================================================================

Автоматическая функция-аксессор для открытой переменной состояния или типа массива возвращает только отдельные элементы. Если вы хотите возвратить весь массив, вам нужно вручную написать функцию для этого.


Что могло произойти, что счет имеет значение или значения в хранилище, но не имеет кода? Пример: http://test.ether.camp/account/5f740b3a43fbb99724ce93a879805f4dc89178b5
=========================================================================================================================================================

Последнее, что делает конструктор, это возвращает код контракта. Затраты газа на это зависят от длины кода и может получиться так, что предоставленного газа недостаточно. Эта ситуация является единственной, когда исключение "out of gas" не обращает изменения состояния, т. е. в этом случае инициализацию переменных состояния.

https://github.com/ethereum/wiki/wiki/Subtleties

После успешного субвыполнения операции CREATE, если операция возвращает x, из оставшегося газа вычитается объем газа 5 * len(x) перед созданием контракта. Если оставшегося газа меньше, чем 5 * len(x), никакой газ не вычитается, код созданного контракта становится пустой строкой, но это не считается исключительным условием - откат не выполняется.


Как использовать .send()?
=====================

Если вы хотите отправить 20 эфира с контракта на адрес `x`, вы используете код `x.send(20 ether);`. Здесь `x` может быть обычным адресом контракта. Если контракт уже явно определяет функцию `send` (и, таким образом, перезаписывает специальную функцию), вы можете использовать код `address(x).send(20 ether);`.

Что делает следующая странная проверка в контракте Custom Token?
======================================================================

::

    if (balanceOf[_to] + _value < balanceOf[_to]) throw;

Целые числа в Solidity (и большинстве других machine-related языков программирования) ограничены определенным диапазоном. Для `uint256` это диапазон от `0` до `2**256 - 1`. Если результат некоторой операции над этими числами не помещается в этот диапазон, он усекается. Эти усечения могут иметь `серьезные последствия <https://en.bitcoin.it/wiki/Value_overflow_incident>`_, так что код вроде того, что выше, необходим для защиты от некоторых атак.


Другие вопросы?
===============

Если у вас есть другие вопросы, можете задать их нам в `gitter <https://gitter.im/ethereum/solidity>`_ или оформить `проблему <https://github.com/ethereum/solidity/issues>`_.
