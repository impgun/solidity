.. index:: type

****
Типы
****

Solidity - это статически типизированный язык, т. е. тип каждой переменной (состояния и локальной) должен быть указан (или, по крайней мере, известен - см. ниже :ref:`type-deduction`) во время компиляции. Solidity предоставляет несколько элементарных типов, которые можно объединять в сложные типы.

.. index:: ! value type, ! type;value

Типы-значения
=============

Описанные ниже типы также называются типами-значениями, потому что переменные этих типов всегда передаются по значению, т. е. всегда копируются, когда используются как аргументы функций или в операциях присваивания.

.. index:: ! bool, ! true, ! false

Булев тип
---------

`bool`: возможные значения - константы `true` и `false`.

Операторы:  

*  `!` (логическое отрицание)
*  `&&` (логическая конъюнкция, "И")
*  `||` (логическая дизъюнкция, "ИЛИ")
*  `==` (проверка на равенство)
*  `!=` (проверка на неравенство)

Операторы `||` и `&&` поддерживают популярные short-circuiting правила. Это означает, что, если в выражении `f(x) || g(y)` функция `f(x)` оценивается в `true`, `g(y)` не будет оцениваться, даже если она может иметь побочные эффекты.

.. index:: ! uint, ! int, ! integer

Целочисленные типы
------------------

`int•` / `uint•`: знаковые и беззнаковые целые числа разных размеров. Ключевые слова от `uint8` до `uint256` с шагом `8` (unsigned от 8 до 256 бит) и от `int8` до `int256`. `uint` и `int` - это псевдонимы типов `uint256` и `int256` соответственно.

Операторы:  

* Сравнения: `<=`, `<`, `==`, `!=`, `>=`, `>` (оценивается в `bool`)  
* Поразрядные: `&`, `|`, `^` (поразрядное исключающее "ИЛИ"), `~` (поразрядное отрицание)  
* Арифметические: `+`, `-`, унарный `-`, унарный `+`, `*`, `/`, `%` (остаток), `**` (возведение в степень)

.. index:: address, balance, send, call, callcode

Адрес
-----

`address`: содержит 20-байтовое значение (размер адреса Ethereum). Типы адресов также имеют члены (см. [Функции для работы с адресами](#functions-on-addresses)) и служат основой (базовыми-?) всех контрактов.

Операторы:  

* `<=`, `<`, `==`, `!=`, `>=` and `>`

Члены адресов
^^^^^^^^^^^^^

* `balance` и `send`

Можно запросить баланс адреса с помощью свойства `balance` и отправить эфир (в веях) на адрес с помощью функции `send`:

::

    address x = 0x123;
    address myAddress = this;
    if (x.balance < 10 && myAddress.balance >= 10) x.send(10);

.. примечание::
    Если `x` - адрес контракта, его код (точнее говоря, его fallback function, если таковая имеется) будет выполнен вместе с вызовом `send` (это ограничение EVM, которое невозможно обойти). Если это выполнение исчерпывает газ или завершается неудачей по иной причине, перевод эфира обращается. В данном случае `send` возвращает `false`.

* `call` и `callcode`

Для взаимодействия с контрактами, которые не соблюдают ABI, предоставляется функция `call`, которая принимает произвольное количество аргументов любого типа. Эти аргументы дополняются до 32 байтов и конкатенируются. Одно исключение имеет место, когда первый аргумент кодируется точно в 4 байта. В этом случае оно не дополняется, чтобы позволить использовать здесь сигнатуры функций.

::

    address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
    nameReg.call("register", "MyName");
    nameReg.call(bytes4(sha3("fun(uint256)")), a);

`call` возвращает булево значение, указывающее, завершилась ли вызванная функция (`true`) или же она вызвала исключение EVM (`false`). Получить доступ к фактическим возвращенным даным невозможно (для этого нам потребовалось бы заблаговременно знать кодировку и размер).

Подобным образом можно использовать функцию `callcode`: разница в том, что используется только код конкретного адреса, а все остальные аспекты (хранилище, баланс, ...) берутся из текущего контракта. Назначение `callcode` - использовать библиотечный код, который хранится в другом контракте. Пользователь должен гарантировать, что формат хранилища в обоих контрактах подходит для использования в callcode.

И `call`, и `callcode` - очень низкоуровневые функции, которые следует использовать только как *last resort*, поскольку они нарушают безопасность типов Solidity.

.. примечание::
    Все контракты наследуют члены address, так что можно запрашивать баланс
    текущего контракта с помощью `this.balance`.

.. index:: byte array, bytes32


Байтовые массивы фиксированного размера
---------------------------------------

`bytes1`, `bytes2`, `bytes3`, ..., `bytes32`. `byte` - это псевдоним для `bytes1`.  

Операторы:  

* Сравнения: `<=`, `<`, `==`, `!=`, `>=`, `>` (оценивается в `bool`)  
* Поразрядные: `&`, `|`, `^` (поразрядное исключающее "ИЛИ"), `~` (поразрядное отрицание)  
* Индексного доступа: если `x` имеет тип `bytesI`, то `x[k]` для `0 <= k < I` возвращает k-й байт (только для чтения).

Члены:

* `.length` возвращает фиксированную длину массива байтов (только для чтения).

Динамический массив байтов
--------------------------

`bytes`:
    байтовый массив динамического размера, см. :ref:`arrays`. Не тип-значение!  
`string`:
    строка динамического размера в кодировке UTF8, см. :ref:`arrays`. Не тип-значение!

На практике используйте `bytes` для необработанных байтовых данных произвольной длины и `string`
для строковых (utf-8) данных произвольной длины. Если вы можете ограничить длину определенным количеством байтов,
всегда используйте один из интервала от `bytes1` до `bytes32`, потому что они гораздо дешевле.

.. index:: literal, literal;integer

Целочисленные литералы
----------------------

Целочисленные литералы - это целые числа произвольной точности, пока они не используются вместе с нелитералом. Например, в `var x = 1 - 2;` значением `1 - 2` является `-1`, которое назначается `x`, и, таким образом, `x` получает тип `int8` -- наименьший тип, содержащий `-1`, хотя естественным типом `1` и `2` на самом деле является `uint8`.    

Можно даже временно превысить максимум в 256 бит, если для вычисления используются только целочисленные литералы: `var x = (0xffffffffffffffffffff * 0xffffffffffffffffffff) * 0;` Здесь `x` получит значение `0` и, таким образом, тип `uint8`.

.. index:: literal, literal;string, string

Строковые литералы
------------------

Строковые литералы записываются в двойных кавычках (`"abc"`). Как и с целочисленными литералами, их тип может различаться, но они неявно конвертируемы в `bytes•`, если помещаются, в `bytes` и в `string`.

.. index:: enum

Перечисления
============

Перечисления - это единственный способ создать в Solidity пользовательский тип. Они явно конвертируемы во все целочисленные типы и обратно, но неявное преобразование не разрешается.

::

    contract test {
        enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
        ActionChoices choice;
        ActionChoices constant defaultChoice = ActionChoices.GoStraight;
        function setGoStraight()
        {
            choice = ActionChoices.GoStraight;
        }
        // Поскольку типы-перечисления не являются частью ABI, сигнатура "getChoice"
        // автоматически будет изменена на "getChoice() returns (uint8)" для всех дел,
        // внешних по отношению к Solidity. Используемый целочисленный тип как раз достаточно
        // велик, чтобы содержать все значения перечисления, т. е., если у вас больше значений,
        // будет использовано `uint16` и т. д.
        function getChoice() returns (ActionChoices)
        {
            return choice;
        }
        function getDefaultChoice() returns (uint)
        {
            return uint(defaultChoice);
        }
    }

.. index:: ! type;reference, ! reference type, storage, memory, location, array, struct

Ссылочные типы
==============

Сложные типы, т. е. типы, которые не всегда помещаются в 256 бит, необходимо обрабатывать более внимательно, чем типы-значения, которые мы уже видели. Поскольку копировать их довольно дорого, мы должны подумать о том, хотим ли мы хранить их в **памяти** (не персистентной) или в **хранилище** (где хранятся переменные состояния).

Расположение данных
-------------------

Каждый сложный тип, т. е. *arrays* и *structs*, имеет дополнительную аннотацию, "расположение данных", которая указывает, хранится ли он в памяти или хранилище. В зависимости от контектса всегда есть значение по умолчанию, но его можно переопределить, добавив к типу `storage` или `memory`. Для параметров функций (включая возвращаемые параметры) значением по умолчанию является `memory`, для локальных переменных - хранилище, и для переменных состояния форсируется расположение хранилище (очевидно).

Есть также третье расположение данных, "calldata", которое представляет собой неизменяемую неперсистентную область, в которой хранятся аргументы функции. Параметры функци (не возвращаемые параметры) внешних функций форсирутся в "calldata" и в этом случае все работает в основном память.

Расположения данных важны потому, что они изменяют работу присваиваний:
Присваивания междуд хранилищем и памятью и переменным состояния (даже из других переменных состояния) всегда приводят к созданию независимой копии.
Присваивания локальным переменным в хранилище, однако, присваивают только ссылку, и эта ссылка всегда указывает на переменную состояния, даже если она тем временем изменяется.
С другой стороны, присваивания из хранящегося в памяти ссылочного типа другому хранящемуся в памяти ссылочному типу не создают копию.

::

    contract c {
      uint[] x; // значение x располагается в хранилище
      // расположение данных memoryArray - память
      function f(uint[] memoryArray) {
        x = memoryArray; // работает, копирует весь массив в хранилище
        var y = x; // работает, назначает указатель, расположение данных y - хранилище
        y[7]; // отлично, возвращает 8-й элемент
        y.length = 2; // отлично, изменяет x через y
        delete x; // отлично, очищает массив, также изменяет y
        // Следующий код не работает; ему потребовалось бы создать новый временный /
        // безымянный массив в хранилище, но хранилище выделяется "статически":
        // y = memoryArray;
        // Это также не работает, поскольку он "сбросил" бы указатель, но нет
        // осмысленного расположения, куда он мог бы указывать.
        // delete y;
        g(x); // вызывает g, передавая ссылку на x
        h(x); // вызывает h и создает независимую временную копию в памяти
      }
      function g(uint[] storage storageArray) internal {}
      function h(uint[] memoryArray) {}
    }

Сводка
^^^^^^

Форсированное расположение данных:
 - параметры (не возвращаемые) внешних функций: calldata
 - переменные состояния: хранилище

Расположение данных по умолчанию:
 - параметры (также возвращаемые) функций: память
 - все другие локальные переменные: хранилище

.. index:: ! array

.. _arrays:

Массивы
-------

Массивы могут иметь размер, фиксируемый во время компиляции, или динамический. Для массивов в хранилище тип элемента может быть произвольным (т. е. другими массивами, отображениями или структурами). Массивы в памяти не могут иметь элементы отображения и должны иметь тип ABI, если он является аргументом общедоступно видимой функции.

Массив фиксированного размера `k` с элементами типа `T` записывается как `T[k]`, массив динамического размера - как `T[]`. Например, массив из 5 динамических массивов типа `uint` будет `uint[][5]` (обратите внимание на нотацию, обратную в сравнении с некоторыми языками). Для доступа ко второму значению uint в третьем динамическом массиве вы использовали бы код `x[2][1]` (индексы отсчитываются от нуля, и доступ работает противоположно объявлению, т. е. `x[2]` снимает один уровень в типе справа).

Переменные типов `bytes` и `string` являются специальными массивами. `bytes` похож на `byte[]`, но он плотно упакован в calldata. `string` эквивалентен `bytes`, но не разрешает доступ к длине или по индексу (пока).

Таким образом, `bytes` следует всегда предпочитать варианту `byte[]`, потому что он дешевле.

.. примечание::
    Если вам нужен доступ к байтовому представлению строки `s`, используйте
    `bytes(s).length` / `bytes(s)[7] = 'x';`. Имейте в виду, что вы
    получаете доступ к низкоуровневым байтам представления в формате utf-8,
    а не к отдельным знакам!

.. index:: ! array;length, length, push, !array;push

Члены
^^^^^

**length**:
    У массивов есть член `length` для хранения количества элементов.
    Для динамических массивов можно изменять размеры в хранилище (не в памяти) путем изменения члена `.length`. Это не происходит автоматически при попытке доступа к элементам вне текущей длины. Как только масив в памяти создан, его размер фиксирован (но динамичен, т. е. может зависеть от параметров времени выполнения).
**push**:
     Динамические массивы в хранилище и `bytes` (не `string`) имеют функцию-член `push`, которую можно использовать для добавления элемента к концу массива. Эта функция возвращает новую длину.

.. warning::
    Пока невозможно использовать массивы массивов во внешних функциях.

.. warning::
    Из-за ограничений EVM пока невозможно возвращать
    динамический контент из вызовов внешних функций. Функция `f` в
    `contract C { function f() returns (uint[]) { ... } }` возвратит
    что-то, если она вызвана из web3.js, но не из Solidity.

    Единственное обходное решение этого пока что - использовать крупные массивы статического размера.


::

    contract ArrayContract {
      uint[2**20] m_aLotOfIntegers;
      // Имейте в виду, что это не пара массивов, а массив пар.
      bool[2][] m_pairsOfFlags;
      // newPairs хранится в памяти - вариант по умолчанию для аргументов функций
      function setAllFlagPairs(bool[2][] newPairs) {
        // присваивание массиву в хранилище заменяет весь массив
        m_pairsOfFlags = newPairs;
      }
      function setFlagPair(uint index, bool flagA, bool flagB) {
        // доступ к несуществующему индексу генерирует исключение
        m_pairsOfFlags[index][0] = flagA;
        m_pairsOfFlags[index][1] = flagB;
      }
      function changeFlagArraySize(uint newSize) {
        // если новый размер меньше, удаленные элементы массива будут очищены
        m_pairsOfFlags.length = newSize;
      }
      function clear() {
        // этот код полностью очищает массивы
        delete m_pairsOfFlags;
        delete m_aLotOfIntegers;
        // идентичный эффект
        m_pairsOfFlags.length = 0;
      }
      bytes m_byteData;
      function byteArrays(bytes data) {
        // байтовые массивы ("bytes") отличаются тем, что хранятся без padding,
        // но с ними можно обращаться так же, как и с "uint8[]"
        m_byteData = data;
        m_byteData.length += 7;
        m_byteData[3] = 8;
        delete m_byteData[2];
      }
      function addFlag(bool[2] flag) returns (uint) {
        return m_pairsOfFlags.push(flag);
      }
      function createMemoryArray(uint size) returns (bytes) {
        // Динамические массивы в памяти создаются с помощью `new`:
        uint[2][] memory arrayOfPairs = new uint[2][](size);
        // Создание динамического массива байтов:
        bytes memory b = new bytes(200);
        for (uint i = 0; i < b.length; i++)
          b[i] = byte(i);
        return b;
      }
    }


.. index:: ! struct, ! type;struct

Структуры
---------

Solidity предоставляет способ определения новых типов в форме структур, который показан в следующем примере:

::

    contract CrowdFunding {
      // Определяет новый тип с двумя полями.
      struct Funder {
        address addr;
        uint amount;
      }
      struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
      }
      uint numCampaigns;
      mapping (uint => Campaign) campaigns;
      function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {
        campaignID = numCampaigns++; // campaignID - это возвращаемая переменная
        // Создает новую структуру и сохраняет ее в хранилище. Мы опустили тип отображения.
        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
      }
      function contribute(uint campaignID) {
        Campaign c = campaigns[campaignID];
            // Создает новую временную структуру в памяти, инициализируя ее указанными значениями,.
            // и копирует ее в хранилище.
            // Имейте в виду, что вы также можете использовать Funder(msg.sender, msg.value) для инициализации.
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
      }
      function checkGoalReached(uint campaignID) returns (bool reached) {
        Campaign c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
          return false;
        c.beneficiary.send(c.amount);
        c.amount = 0;
        return true;
      }
    }

Этот контракт не предоставляет полную функциональность краудфандинга, но содержит базовые концепции, необходимые для понимания структур. Структуры можно использовать внутри отображений и массивов, и они сами могут содержать отображения и массивы.

Структура не может содержать член собственного типа, хотя сама структура может быть типом-значением члена отображения. Это ограничение необходимо потому, что размер структуры должен быть конечным.

Заметьте, как во всех функциях структура назначается локальной переменной (расположения данных хранилища по умолчанию). Это не копирует стурктуру, но только сохраняет ссылку, чтобы присваивания членам локальной переменной на самом деле приводили к записи в состояние.

Конечно, вы также можете получать непосредственный доступ к членам структуры, не присваивая ее локальной переменной, как в коде `campaigns[campaignID].amount = 0`.

.. index:: !mapping

Отображения
===========

Типы-отображения объявляются как `mapping _KeyType => _ValueType`, где `_KeyType` может быть почти любым типом, за исключением отображения, а `_ValueType`может быть любым типом, включая отображения.

Отображения можно рассматривать как хеш-таблицы, которые виртуально инициализированы так, что существуют все возможные ключи, отображаемые на значения, байтовые представления которых содержат только нули. Однако на этом сходство заканчивается: данные ключей на самом деле не хранятся в отображении, а только их хеш `sha3` используется для просмотра значения.

В силу этого отображения не имеют длины или концепции "заданного" ключа или значения.

Отображения поддерживаются только для переменных состояни (или как ссылочные типы хранилища во внутренних функциях).

.. index:: assignment, ! delete, lvalue

Операторы, включающие LValues
=============================

Если `a` является LValue (т. е. переменной или чем-то, что может находиться слева от знака присваивания), доступны следующие сокращенные формы записи операторов:

`a += e` эквивалентно `a = a + e`. Операторы `-=`, `*=`, `/=`, `%=`, `a |=`, `&=` и `^=` определены соответствующим образом. `a++` и `a--` эквивалентны `a += 1` / `a -= 1`, но само выражение имеет прежнее значение `a`. Напротив, `--a` и `++a` оказывают влияние на `a`, но возвращают значение после изменения.

delete
------

`delete a` назначает первоначальное значение типа `a`. Т. е. для целых чисел это эквивалент `a = 0`, но его также можно использовать с массивами, в случае чего оно назначет динамический массив нулевой длины или статический массив той же длины со всеми сброшенными элементами. Для структур оно назначает структуру, у которой сброшены все члены.

`delete` не оказывает влияния на целые отображения (поскольку ключи отображений могут быть произвольными и обычно неизвестны). Таким образом, если вы удаляете структуру, оно сбросит все члены, которые не являются отображениями, и также сделает заход в члены, если они не являются отображениями. Однако отдельные ключи и то, на что они отображаются, могут быть удалены.

Важно отметить, что `delete a` на самом деле работает как присваивание `a`, т. е. сохраняет новый объект в `a`.

::

    contract DeleteExample {
      uint data;
      uint[] dataArray;
      function f() {
        uint x = data;
        delete x; // обнуляет x, не влияет на data
        delete data; // обнуляет data, не влияет на x, которая по-прежнему содержит копию
        uint[] y = dataArray;
        delete dataArray; // обнуляет dataArray.length, но, поскольку uint[] является сложным объектом, также
        // влияет на y, которая является псевдонимом объекта в хранилище
        // С другой стороны, код "delete y" недопустим, потому что присваивания локальным переменным,
        // ссылающиеся на объекты в хранилище, можно выполнять только из существующих объектов в хранилище.
      }
    }

.. index:: ! type;conversion, ! cast

Преобразования элементарных типов
=================================

Неявные преобразования
----------------------

Если оператор применяется к разным типам, компилятор пытается неявно преобразовать один из операндов в тип другого (то же верно для присваиваний). В общем, неявное преобразование между типами-значениями возможно, если оно имеет смысл семантически и при этом не утрачивается никакая информация: `uint8` может быть преобразовано в `uint16`, а `int128` в `int256`, но `int8` не может быть преобразовано в `uint256` (потому что `uint256` не может, например, содержать `-1`). Более того, беззнаковые целые числа могут быть преобразовано в bytes того же или большего размера, но не наоборот. Любой тип, который может быть преобразован в `uint160`, может также быть преобразован в `address`.

Явные преобразования
--------------------

Если компилятор не разрешает неявное преобразование, но вы знаете, что делаете, иногда возможно неявное преобразование типа::

    int8 y = -3;
    uint x = uint(y);

В конце этого фрагмента кода `x` будет иметь значение `0xfffff..fd` (64 шестнадцатиричных знака), что равно -3 в two's complement representation of 256 bits.

Если тип явно преобразуется в меньший тип, старшие биты отбрасываются::

    uint32 a = 0x12345678;
    uint16 b = uint16(a); // теперь b равно 0x5678

.. index:: ! type;deduction, ! var

.. _type-deduction:

Выведение типа
==============

Ради удобства не всегда необходимо явно указывать тип переменной; компилятор автоматически выводит его из типа первого выражения, назначаемого переменной::

    uint20 x = 0x123;
    var y = x;

Здесь типом `y` будет `uint20`. Использовать `var` невозможно для параметров функций и возвращаемых параметров.

.. предупреждение::
    Тип выводится только из первого назначения, так что цикл в следующем фрагменте бесконечен, поскольку `i` будет иметь тип
    `uint8` и любое значение этого типа меньше `2000`.
    `for (var i = 0; i < 2000; i++) { ... }`

