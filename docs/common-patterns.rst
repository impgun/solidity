############################
Часто встречающиеся паттерны
############################

.. index:: access;restricting

*******************
Ограничение доступа
*******************

Ограничение доступа - частый паттерн в контрактах. Имейте в виду, что вы не можете помешать человеку или компьютеру прочитать содержимое ваших транзакций или состояние вашего контракта. Вы можете немного затруднить это с помощью шифрования, но если предполагается, что ваш контракт должен читать данные, их сможет прочитать кто угодно.

Вы можете ограничить доступ с правом на чтение к состоянию вашего контракта для **других контрактов**. По сути, это поведение имеет место по умолчанию, если только вы не объявляете свои переменные состояния как `public`.

Более того, вы можете ограничить, кто может изменять состояние вашего контракта или вызывать функции вашего контракта, и именно об этом данная страница.

.. index:: function;modifier

Использование **модификаторов функций** позволяет легко читать эти ограничения.

.. {% include open_link gist="fe4ef267cbdeac151b98" %}

::

    contract AccessRestriction {
        // Эти переменные будут назначены на этапе
        // конструирования, где `msg.sender` - это счет,
        // создающий данный контракт.
        address public owner = msg.sender;
        uint public creationTime = now;

        // Модификаторы можно использовать для
        // изменения тела функции.
        // Если этот модификатор используется, он предварит
        // проверку, которая проходит, только если
        // функция вызывается с
        // определенного адреса.
        modifier onlyBy(address _account)
        {
            if (msg.sender != _account)
                throw;
            // На забудьте "_"! Это будет заменено фактическим
            // телом функции
            // при вызове модификатора.
            _
        }

        /// Сделаем `_newOwner` новым владельцем этого
        /// контракта.
        function changeOwner(address _newOwner)
            onlyBy(owner)
        {
            owner = _newOwner;
        }

        modifier onlyAfter(uint _time) {
            if (now < _time) throw;
            _
        }

        /// Очищает информацию о владении.
        /// Может только быть вызвана через 6 недель
        /// после создания контракта.
        function disown()
            onlyBy(owner)
            onlyAfter(creationTime + 6 weeks)
        {
            delete owner;
        }

        // Этот модификатор требует, чтобы с вызовом функции
        // была связана определенная комиссия.
        // Если вызывающий отправил слишком много, он получает
        // сдачу, но только после тела функции.
        // Это опасно, потому что, если функция явно
        // использует `return`, это не будет
        // сделано!
        modifier costs(uint _amount) {
            if (msg.value < _amount)
                throw;
            _
            if (msg.value > _amount)
                msg.sender.send(_amount - msg.value);
        }

        function forceOwnerChange(address _newOwner)
            costs(200 ether)
        {
            owner = _newOwner;
            // просто пример условия
            if (uint(owner) & 0 == 1)
                // в том случае чрезмерно уплаченные комиссии
                // не будут возвращены
                return;
            // в противном случае лишняя комиссия возвращается
        }
    }

Более специализированный способ ограничения доступак вызовам функций будет обсуждаться в следующем примере.

.. index:: state machine

****************
Машина состояний
****************

Контракты часто работают как машина состояний, что означает, что они имеют определенные **стадии**, на которых они ведут себя по-разному, или на которых можно вызывать разные функции. Вызов функции часто завершает стадию и переводит контракт в следующую стадию (особенно если контракт моделирует **взаимодействие**). Также часто встречается, что некоторые стадии автоматически достигаются в определенный момент **времени**.

Примером этого является контракт слепого аукциона, который начинается на стадии "прием ставок вслепую", затем переходит в "обнародование ставок", что завершается стадией "определение результата аукциона".

.. index:: function;modifier

В этой ситуации можно использовать модификаторы функций для моделирования состояний и предотвращения некорректного использования контракта.

Пример
======

В следующем примере модификатор `atStage` гарантирует, что функция может быть вызвана только на определенной стадии.

Переходы с автоматическим таймингом обрабатываются модификатором `timeTransitions`, который следует использовать со всеми функциями.

.. примечание::
    **Порядок модификаторов важен**.
    Если atStage объединен
    с timedTransitions, убедитесь, что вы упоминаете его после
    последнего, чтобы учесть
    новую стадию.

Наконец, модификатор `transitionNext` можно использовать для автоматического перехода к следующей стадии при завершении функции.

.. note::
    **Модификатор может быть пропущен**.
    Поскольку модификаторы применяются путем простой замены кода,
    а не с помощью вызова функции,
    код в модификаторе transitionNext
    может быть пропущен, если сама функция использует
    return. Если вы хотите сделать это, не забудьте
    вызвать nextStage вручную из этих функций.

.. {% include open_link gist="0a221eaceb6d708bf271" %}

::

    contract StateMachine {
        enum Stages {
            AcceptingBlindedBids,
            RevealBids,
            AnotherStage,
            AreWeDoneYet,
            Finished
        }
        // Это текущая стадия.
        Stages public stage = Stages.AcceptingBlindedBids;

        uint public creationTime = now;

        modifier atStage(Stages _stage) {
            if (stage != _stage) throw;
            _
        }
        function nextStage() internal {
            stage = Stages(uint(stage) + 1);
        }
        // Выполняет транзакции с таймингом. Не забудьте упомянуть этот
        // модификатор первым, в противом случае защитники
        // не примут новую стадию во внимание.
        modifier timedTransitions() {
            if (stage == Stages.AcceptingBlindedBids &&
                        now >= creationTime + 10 days)
                nextStage();
            if (stage == Stages.RevealBids &&
                    now >= creationTime + 12 days)
                nextStage();
            // Переходы в другие стадии по транзакции
        }
        
        // Порядок модификаторов здесь важен!
        function bid()
            timedTransitions
            atStage(Stages.AcceptingBlindedBids)
        {
            // Мы не будем реализовывать это здесь
        }
        function reveal()
            timedTransitions
            atStage(Stages.RevealBids)
        {
        }

        // Этот модификатор переходит к следующей стадии
        // после выполнения функции.
        // Ели вы используете `return` в функции,
        // `nextStage` не будет вызвана
        // автоматически.
        modifier transitionNext()
        {
            _
            nextStage();
        }
        function g()
            timedTransitions
            atStage(Stages.AnotherStage)
            transitionNext
        {
            // Если вы хотите использовать здесь `return`,
            // вы должны вручную вызвать `nextStage()`.
        }
        function h()
            timedTransitions
            atStage(Stages.AreWeDoneYet)
            transitionNext
        {
        }
        function i()
            timedTransitions
            atStage(Stages.Finished)
        {
        }
    }
