*****************************************
Единицы измерения и глобальные переменные
*****************************************

.. index:: wei, finney, szabo, ether

Единицы измерения эфира
=======================

Численный литерал может иметь суффикс `wei`, `finney`, `szabo` или `ether`, указывающий единицу измерения, при этом значения без суффикса соответствуют "wei", например `2 ether == 2000 finney` равно `true`.

.. index:: time, seconds, minutes, hours, days, weeks, years

Единицы измерения времени
=========================

Суффиксы `seconds`, `minutes`, `hours`, `days`, `weeks` и `years` после численных литералов можно использовать для преобразования единиц времени, при этом базовой единицей является секунда и действуют следующие упрощения:

 * `1 == 1 second`
 * `1 minutes == 60 seconds`
 * `1 hours == 60 minutes`
 * `1 days == 24 hours`
 * `1 weeks = 7 days`
 * `1 years = 365 days`

Будьте внимательны, если выполняете вычисления с календарем, используя эти единицы, потому что не каждый год содержит 365 дней и не каждые сутки 24 часа из-за `leap seconds <https://en.wikipedia.org/wiki/Leap_second>`_. Из-за того факта, что leap seconds невозможно предсказать, точную календарную библиотеку должен обновлять внешний оракул.

Эти суффиксы невозможно применять к переменным. Если вы хотите интерпретировать некоторую входную переменную в днях (например), это можно сделать следующим образом::

    function f(uint start, uint daysAfter) {
      if (now >= start + daysAfter * 1 days) { ... }
    }

Специальные переменные и функции
================================

Есть специальные переменные и функции, которые всегда существуют в глобальном пространстве имен и используются в основном для предоставления информации о блокчейне.

.. index:: block, coinbase, difficulty, number, block;number, timestamp, block;timestamp, msg, data, gas, sender, value, now, gas price, origin


Свойства блока и транзакции
---------------------------

 - `block.coinbase` (`address`): адрес майнера текущего блока
 - `block.difficulty` (`uint`): сложность текущего блока
 - `block.gaslimit` (`uint`): ограничение газа в текущем блоке
 - `block.number` (`uint`): номер текущего блока
 - `block.blockhash` (`function(uint) returns (bytes32)`): хеш текущего блока - только для 256 последних блоков
 - `block.timestamp` (`uint`): временная метка текущего блока
 - `msg.data` (`bytes`): полные данные вызова calldata-?
 - `msg.gas` (`uint`): оставшийся газ
 - `msg.sender` (`address`): отправитель сообщения (текущий вызов)
 - `msg.sig` (`bytes4`): первые 4 байта calldata (т. е. идентификатор функции)
 - `msg.value` (`uint`): количество wei, отправленное с сообщением
 - `now` (`uint`): временная метка текущего блока (псевдоним для `block.timestamp`)
 - `tx.gasprice` (`uint`): цена газа-? для транзакции
 - `tx.origin` (`address`): отправитель трензакции (полная цепь вызовов)

.. note::
    Значения всех членов `msg`, включая `msg.sender` и
    `msg.value`, могут изменяться для каждого **внешнего** вызова функции.
    Это включает вызовы библиотеных функций.

    Если вы хотите реализовать ограничения доступа в библиотечных функциях с помощью
    `msg.sender`, вы должны вручную предоставить значение
    `sg.sender` в качестве аргумента.

.. note::
    Хеши блоков доступны не для всех блоков по причинам масштабируемости.
    Вам доступны только хеши последних 256 блоков, а все остальные
    значения будут нулевыми.

.. index:: sha3, ripemd160, sha256, ecrecover, addmod, mulmod, cryptography, this, super, selfdestruct, balance, send

Математические и криптографические функции
----------------------------------------

`addmod(uint x, uint y, uint k) returns (uint)`:
    вычисляет `(x + y) % k`, где сложение выполняется с произвольной точностью и не wrap around at `2**256`.
`mulmod(uint x, uint y, uint k) returns (uint)`:
    вычисляет `(x * y) % k`, при этом умножение выполняется с произвольной точностью и не wrap around at `2**256`.
`sha3(...) returns (bytes32)`:
    вычисляет хеш Ethereum-SHA-3 (плотно упакованных) аргументов
`sha256(...) returns (bytes32)`:
    вычисляет хеш SHA-256 (плотно упакованных) аргументов
`ripemd160(...) returns (bytes20)`:
    вычисляет хеш RIPEMD-160 (плотно упакованных) аргументов
`ecrecover(bytes32, byte, bytes32, bytes32) returns (address)`:
    восстанавливает открытый ключ из elliptic curve signature - принимает аргументы (data, v, r, s)

Выше "плотно упакованный" означает, что аргументы кокатенированы без padding. Это означает, что все следующие вызовы идентичны::

    sha3("ab", "c")
    sha3("abc")
    sha3(0x616263)
    sha3(6382179)
    sha3(97, 98, 99)

Если padding необходим, можно использовать явные преобразования типов: `sha3("\x00\x12")` - это то же самое, что и `sha3(uint16(0x12))`.

Возможно, при выполнении функции `sha256`, `ripemd160` или `ecrecover` в *частном блокчейне* у вас закончится газ. Причина этого в том, что они реализованы как так называемые прекомпилированные контракты, которые на самом деле существуют только после получения первого сообщения (хотя их код контракта жестко закодирован). Сообщения несуществующим контрактам более дороги и, таким образом, выполнение доходит до ошибки исчерпания газа. Обходной способ решения этой проблемы - сначала отправить, например, 1 Wei каждому из контрактов, прежде чем использовать их в фактических контрактах. Этой проблемы нет в официальной или тестовой сети.

.. index:: this, selfdestruct

Contract Related
----------------

`this` (тип текущего контракта):
    текущий контракт, явно преобразуемый в `address`
`selfdestruct(address)`:
    уничтожает текущий контракт, отправляя его средства по указанному адресу

Кроме того, все функции текущего контракта, включая текущую функцию, are callable directly.

