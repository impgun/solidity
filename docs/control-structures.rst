#################################
Выражения и управляющие структуры
#################################

.. index:: if, else, while, for, break, continue, return, switch, goto

Управляющие структуры
=====================

В Solidity доступно большинство управляющих структур C/JavaScript, за исключением 'switch' и 'goto'. Таким образом, это 'if', 'else', 'while', 'for', 'break', 'continue', 'return' и '? :' с такой же семантикой, что и в C / JavaScript.

Обычные скобки в условных операторах опускать *нельзя*, но фигурные скобки вокруг одиночных выражений можно.

Имейте в виду, что, в отличие от C и JavaScript, в Solidity не выполняется преобразование типов из небулева в булев, так что код 'if (1) { ... }' *не* является допустимым кодом Solidity.

.. index:: ! function;call, function;internal, function;external

Вызовы функций
==============

Внутренние вызовы функций
-------------------------

Функции текущего контракта можно вызывать непосредственно ("внутренне"), а также рекурсивно, как показано в этом бессмысленном примере::

    contract c {
      function g(uint a) returns (uint ret) { return f(); }
      function f() returns (uint ret) { return g(7) + f(); }
    }

Эти вызовы функций транслируются в простые переходы jumps в EVM. Это имеет тот эффект, что текущая память не очищается, т. е. передача ссылок на память внутренне вызываемым функциям очень эффективна. Внутренне можно вызывать только функции того же контракта.

Внешние вызовы функций
----------------------

Выражение 'this.g(8);' также является допустимым вызовом функции, но в этот раз функция будет вызвана "внешне", с помощью сообщения, а не напрямую с помощью jumps. Функции других контрактов необходимо вызывать внешне. Для внешнего вызова все аргументы функции должны быть скопированы в память.

При вызове функций других контрактов можно указать количество Wei и газа, отправляемых с вызовом::
    
    contract InfoFeed {
      function info() returns (uint ret) { return 42; }
    }
    contract Consumer {
      InfoFeed feed;
      function setFeed(address addr) { feed = InfoFeed(addr); }
      function callFeed() { feed.info.value(10).gas(800)(); }
    }

Обратите внимание, что выражение 'InfoFeed(addr)' выполняет явное преобразование типа, заявляя, что "мы знаем, что тип контракта по указанному адресу - 'InfoFeed'", и при этом конструктор не выполняется. Мы могли бы также присвоить значение напрямую: 'function setFeed(InfoFeed _feed) { feed = _feed; }'. Знайте о том факте, что 'feed.info.value(10).gas(800)' только (локально) задает значение и объем газа, отправляемые с вызовом функции, и только скобки в конце запускают фактический вызов.

Именованные вызовы и анонимные параметры функций
------------------------------------------------

Аргументы вызовов функций можно указывать по имени в любом порядке, и имена неиспользуемых параметров (особенно возвращаемых) можно опускать.

::

    contract c {
      function f(uint key, uint value) { ... }
      function g() {
        // именованные аргументы
        f({value: 2, key: 3});
      }
      // опущенные параметры
      function func(uint k, uint) returns(uint) {
        return k;
      }
    }

Порядок оценки выражений
========================

Порядок оценки выражений не задан (выражаясь более формально, не задан порядок, в котором оцениваются дочерние узлы одного узла в дереве выражения, но, конечно, они оцениваются до самого узла). Гарантируется только лишь то, что операторы выполняются по порядку и что выполняется short-circuiting булевых выражений.

.. index:: ! assignment

Присваивание
============

.. index:: ! assignment;destructuring

Присваивание с деструктурированием и возврат нескольких значений
----------------------------------------------------------------

В Solidity внутри разрешены типы-кортежи, т. е. список объектов потенциально разных типов, размер которых известен во время компиляции. Эти кортежи можно использовать, чтобы возвращать сразу несколько значений и также назначать их нескольким переменным (или LValues в общем) одновременно::

    contract C {
      uint[] data;
      function f() returns (uint, bool, uint) {
        return (7, true, 2);
      }
      function g() {
        // Объявляются переменные и им присваиваются значения. Явно указать тип невозможно.
        var (x, b, y) = f();
        // Присвоение значений существующим переменным.
        (x, y) = (2, 7);
        // Чато используемый трюк для обмена значениями -- не работает для  non-value storage types.
        (x, y) = (y, x);
        // Компоненты можно опускать (для объявлений переменных тоже).
        // Если кортеж заканчивается пустым компонентом,
        // остальные значения отбрасываются.
        (data.length,) = f(); // Присваивает length значение 7
        // То же самое можно сделать слева.
        (,data[3]) = f(); // Присваивает data[3] значение 2
        // Компоненты можно опускать только с левой стороны присваиваний, за
        // единственным исключением:
        (x,) = (1,);
        // (1,) - это единственный способ указать однокомпонентный кортеж,
        // потому что (1) эквивалентно 1.
      }
    }

Трудности работы с массивами и структурами
------------------------------------------

Семантика присваивания немного сложнее в случае незначимых типов, таких как массивы и структуры. Присваивание значения переменной состояния всегда приводит к созданию независимой копии. С другой стороны, присваивание значения локальной переменной создает независимую копию только для элементарных типов, т. е. статических типов, помещающихся в 32 байта. Если структуры или массивы (включая 'bytes' и 'string' назначаются из переменной состояния локальной переменной, локальная переменная содержит ссылку на оригинальную переменную состояния. Второе присваивание локальной переменной не изменяет состояние, но только изменяет ссылку. Присваивание значений членам (или элементам) локальной переменной изменяет состояние.

.. index:: ! exception, ! throw

Исключения
==========

В некоторых ситуациях исключения генерируются автоматически (см. ниже). Вы можете использовать инструкцию 'throw', чтобы генерировать исключение вручную. Эффект исключения таков, что выполняемый вызов останавливается и обращается (т. е. все изменения состояния и балансов отменяются), а исключение "всплывает" по вызовам функций Solidity (исключения 'отправляются', а низкоуровневые функции 'call' and 'callcode', those return `false` in case of an exception).

Перехватьывать исключения пока невозможно.

В следующем примере показано, как можно использовать 'throw', чтобы легко обратить передачу эфира, и как проверить возвращаемое значение 'send'::

    contract Sharer {
        function sendHalf(address addr) returns (uint balance) {
            if (!addr.send(msg.value/2))
                throw; // передаваемые средства возвращаются Sharer
            return this.balance;
        }
    }

В настоящее время исключения автоматически генерируются в Solidity в трех ситуациях:

1. Если вы получаете доступ к массиву за его длиной (т. е. 'x[i]', где 'i >= x.length').
2. Если функция, вызванная путем вызова сообщения, не завершается правильно (т. е. исчерпывает газ или сама генерирует исключение).
3. Если вызывается несуществующая функция библиотеки или эфир отправляется библиотеке.

Внутренне Solidity выполняет "invalid jump", когда генерируется исключение, и, таким образом, указывает EVM обратить все изменения состояния. Причина этого в том, что нет безопасного способа продолжить выполнение, потому что ожидаемый эффект не был достигнут. Поскольку мы хотим сохранить атомарность транзакций, самое безопасное - это обратить все изменения и выполнить всю транзакцию (или, по крайней мере, вызов) без эффекта.

