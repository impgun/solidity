*******************************
Формат исходного файла Solidity
*******************************

Исходные файлы могут содержать произвольное количество определений контрактов и включать директивы(директивы включения?).

.. index:: source file, ! import

Импорт других исходных файлов
=============================

Синтаксис и семантика
---------------------

Solidity поддерживает инструкции импорта, которые очень похожи на те, что доступны в JavaScript (начиная с ES6), хотя Solidity неизвестра концепция "экспорта по умолчанию".

На глобальном уровне вы можете использовать инструкции импорта следующего формата:

`import "filename";` импортирует все глобальные символы из "filename" (и символы, импортированные туда) в текущую глобальную область видимости (отличается от области видимости в ES6, но обратно совместима для Solidity).

`import * as symbolName from "filename";` создает новый глобальный символ `symbolName`, все члены которого являются глобальными символами из `"filename"`.

`import {symbol1 as alias, symbol2} from "filename";` создает новые глобальные символы `alias` и `symbol2`, которые ссылаются на `symbol1` и `symbal2` из `"filename"` соответственно.

Другой синтаксис не является частью ES6, но, вероятно, удобен:

`import "filename" as symbolName;` эквивалентно `import * as symbolName from "filename";`.

Пути
----

В приведенном выше коде `filename` всегда обрабатывается как путь с `/` в качестве разделителя каталогов, `.` как текущий и `..` как родительский каталоги. Имена путей, которые не начинаются с `.`, обрабатываются как абсолютные пути.

Чтобы импортировать файл `x` из того же катлога, что и текущий файл, используйте команду `import "./x" as x;`. Если вы используйте вместо этого `import "x" as x;`, может получиться ссылка на другой файл (в глобальном "каталоге включения").

Фактическое разрешение путе зависит от компилятора (см. ниже). В общем, иерархия каталогов не обязана строго соответствовать вашей локальной файловой системе, она может также отображаться на ресурсы, обнаруженные, например, с помощью ipfs, http или git.

Использование в фактических компиляторах
----------------------------------------

При вызове компилятора можно указать не только, как обнаруживать первый элемент пути, но и ремэппинги префикса пути, чтобы, например, путь `github.com/ethereum/dapp-bin/library` переотображался на `/usr/local/dapp-bin/library`, и компилятор будет читать файлы оттуда. Если ключи переотображения являются префиксами друг друга, сначала пробуется длиннейший. Это делает возможным "fallback-remapping" с, например, отображением `""` на `"/usr/local/include/solidity"`.

**solc**:

Для solc (компилятора командной строки), эти переназначения предоставляются как аргументы `key=value`, где часть `=value` необязательна (и по умолчанию представляет ключ в этом случае). Все значения переназначения, которые являются обычными файлами, компилируются (включая их зависимости). Этот механизм полностью обратно совместим (при условии что никакое имя файла не содержит =) и, таким образом, не является breaking change.

Так, например, если вы клонируете `github.com/ethereum/dapp-bin/` на локальный компьютер в каталог `/usr/local/dapp-bin`, вы можете использовать в своем исходном файле следующее:

`import "github.com/ethereum/dapp-bin/library/iterable_mapping.sol" as it_mapping;`

а затем запустить компилятор следующим образом:

`solc github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ source.sol`

Имейте в виду, что solc позволяет включать файлы только из некорторых каталогов. Они должны находиться в каталоге (или подкаталоге) одного из явно указанных исходных файлов или в каталоге (или подкаталоге) цели переназначения. Если вы хотите разрешить непосредственные абсолютные включения, просто добавьте переназначение `=/`.

Если есть несколько переназначений, ведущих к действительному файлу, выбирается переназначение с длиннейшим общим префиксом.

**browser-solidity**:

Браузерный компилятор <https://chriseth.github.io/browser-solidity>`_ обеспечивает автоматическое переназначение для github и также автоматически получает файл по сети:
Например, импортировать итерируемое отображение можно так:
`import "github.com/ethereum/dapp-bin/library/iterable_mapping.sol" as it_mapping;`.

Возможно, в будущем будут добавлены другие провайдеры исходного кода.


.. index:: ! comment, natspec

Комментарии
===========

Поддерживаются однострочные (`//`) и многострочные (`/*...*/`) комментарии.

Есть специальные типы комментариев, которые называются natspec (документация еще не написана). Они указываются с помощью тройной косой черты (`///`) или двумя звездочками (`/** ... */`). Прямо перед объявлениями функций или инструкциями вы можете использовать в них теги в стиле doxygen для документирования функций, аннотирования условий для формальной верификации и предоставления **текста подтверждений**, который отображается пользователям, если они хотят вызвать функцию.
