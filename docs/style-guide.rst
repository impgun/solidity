.. index:: style, coding style

#############
Руководство по стилю
#############

************
Введение
************

В этом руководстве описаны конвенции написания кода Solidity. Руководство следует рассматривать как развивающийся документ, который будет изменяться со временем по мере обнаружения полезных конвенций и устаревания других.

Во многих проектах будут использоваться свои руководства по стилю. В случае конфликтов приоритет должен отдаваться руковдоствам, специфичным для проекта.

Структура и многие из рекомендаций в этом руководстве были взяты из руководства по стилю Python `pep8 style guide <https://www.python.org/dev/peps/pep-0008/>`_.

Цель этого руководства - *не* представить правильный или лучший способ написания кода Solidity, а *согласованность*. Цитата из `pep8 <https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds>`_ хорошо выражает эту идею.

    Руководство по стилю касается согласованности. Согласованность в этом руководстве по стилю важна. Согласованность в проекте еще важнее. Наиболее важна согласованность в пределах модуля или функции.
    Но самое важное - это знать, когда быть несогласованным -- иногда руководство по стилю просто неприменимо. Когда сомневаетесь, руководствуйтесь best judgment. Посмотрите на другие примеры и решите, что выглядит лучше. И спрашивайте, не колеблясь! 


***********
Макет кода
***********


Отступы
===========

Используйте 4 пробела на уровень отступа.

Табуляция или пробелы
==============

Предпочтительным способом отступа являются пробелы.

Смешения знаков табуляции и пробелов следует избегать.

Пустые строки
===========

Окружайте объявления верхнего уровня в коде Solidity двумя пустыми строками.

Да::

    contract A {
        ...
    }


    contract B {
        ...
    }


    contract C {
        ...
    }

Нет::

    contract A {
        ...
    }
    contract B {
        ...
    }

    contract C {
        ...
    }

Внутри контракта окружайте объявления функций одинарными пустыми строками.

Пустые строки можно опускать между группами связанных однострочных функций (таких как функции-заглушки для абстрактного контракта)

Да::

    contract A {
        function spam();
        function ham();
    }


    contract B is A {
        function spam() {
            ...
        }

        function ham() {
            ...
        }
    }

Нет::

    contract A {
        function spam() {
            ...
        }
        function ham() {
            ...
        }
    }

Кодировка исходных файлов
====================

Предпочтительно использовать кодировку UTF-8 или ASCII.

Импорт
==========

Выражения импорта всегда следует указывать в начале файла.

Да::

    import "owned";


    contract A {
        ...
    }


    contract B is owned {
        ...
    }

Нет::

    contract A {
        ...
    }


    import "owned";


    contract B is owned {
        ...
    }

Пустые места в выражениях
=========================

Избегайте лишнего пустого места в следующих ситуациях:

* Сразу же после.перед обычных, квадратных или фигурных скобок.

Да: `spam(ham[1], Coin({name: "ham"}));`

Нет: `spam( ham[ 1 ], Coin( { name: "ham" } ) );`

* Непосредственно перед запятой и точкой с запятой:

Да: `function spam(uint i, Coin coin);` 

Нет: `function spam(uint i , Coin coin) ;`

* Более одного пробела вокруг присваивания или другого оператора для выравнивания с другим:

Да::

    x = 1;
    y = 2;
    long_variable = 3;

Нет::

    x             = 1;
    y             = 2;
    long_variable = 3;


Управляющие структуры
==================

Фигурные скобки, обозначающие тело контракта, библиотеки, функции или структуры, следует:

* открывать на той же строке, что и объявление
* закрывать на отдельной строке с тем же уровнем отступа, что и в начале объявления.
* открывающей фигурной скобке должен предшествовать один пробел.

Да::

    contract Coin {
        struct Bank {
            address owner;
            uint balance;
        }
    }

Нет::

    contract Coin
    {
        struct Bank {
            address owner;
            uint balance;
        }
    }

Те же рекомендации относятся к управляющим структурам `if`, `else`, `while` и `for`.

Кроме того, должен быть один пробел между управляющими структурами `if`, `while` и `for` и скобочным блоком, представляющим условие, а также один пробел между условием в скобках и открывающей фигурной скобкой.

Да::

    if (...) {
        ...
    }

    for (...) {
        ...
    }

Нет::

    if (...)
    {
        ...
    }

    while(...){
    }

    for (...) {
        ...;}

Для управляющих структур, тело которых содержит один оператор, можно опускать фигурные скобки, *если* оператор содержится на одной строке.

Да::

    if (x < 10)
        x += 1;

Нет::

    if (x < 10)
        someArray.push(Coin({
            name: 'spam',
            value: 42
        }));

Для блоков `if` с предложением `else` или `else if` предложение `else` должно находиться на отдельной строке, следуя за предыдущей закрывающей скобкой. Скобки блока else должна соответствовать тем же правилам, что и другие условные управляющие структуры.

Да::

    if (x < 3) {
        x += 1;
    }
    else {
        x -= 1;
    }


    if (x < 3)
        x += 1;
    else
        x -= 1;

Нет::

    if (x < 3) {
        x += 1;
    } else {
        x -= 1;
    }

Объявление функции
====================

В случае объявлений коротких функций рекомендуется указывать открывающую фигурную скобку тела функции на той же строке, что и обявление функции.

Закрывающую фигурную скобку следует вводить на том же уровне отступа, на котором находится объявление функции.

Открывающей фигурной скобе должен предшествовать один пробел.

Да::

    function increment(uint x) returns (uint) {
        return x + 1;
    }

    function increment(uint x) public onlyowner returns (uint) {
        return x + 1;
    }

Нет::

    function increment(uint x) returns (uint)
    {
        return x + 1;
    }

    function increment(uint x) returns (uint){
        return x + 1;
    }

    function increment(uint x) returns (uint) {
        return x + 1;
        }

    function increment(uint x) returns (uint) {
        return x + 1;}

Модификаторы видимости функции следует указывать перед любыми пользовательскими модификаторами.

Да::

    function kill() public onlyowner {
        selfdestruct(owner);
    }

Нет::

    function kill() onlyowner public {
        selfdestruct(owner);
    }

В случае объявления длинных функций рекомендуется располагать каждый аргумент на отдельной строке на том же уровне отступа, что и тело функции. Закрывающая скобка и открывающая фигурная скобка должны находиться на отдельной строке на том же уровне отступа, что и объявление функции.

Да::

    function thisFunctionHasLotsOfArguments(
        address a,
        address b,
        address c,
        address d,
        address e,
        address f,
    ) {
        do_something;
    }

Нет::

    function thisFunctionHasLotsOfArguments(address a, address b, address c,
        address d, address e, address f) {
        do_something;
    }

    function thisFunctionHasLotsOfArguments(address a,
                                            address b,
                                            address c,
                                            address d,
                                            address e,
                                            address f) {
        do_something;
    }

    function thisFunctionHasLotsOfArguments(
        address a,
        address b,
        address c,
        address d,
        address e,
        address f) {
        do_something;
    }

Если объявление длинной функции имеет модификкаторы, каждый модификатор следует указать на отдельной строке.

Да::

    function thisFunctionNameIsReallyLong(address x, address y, address z)
        public
        onlyowner
        priced
        returns (address)
    {
        do_something;
    }

    function thisFunctionNameIsReallyLong(
        address x,
        address y,
        address z,
    )
        public
        onlyowner
        priced
        returns (address)
    {
        do_something;
    }

Нет::

    function thisFunctionNameIsReallyLong(address x, address y, address z)
                                          public
                                          onlyowner
                                          priced
                                          returns (address) {
        do_something;
    }

    function thisFunctionNameIsReallyLong(address x, address y, address z)
        public onlyowner priced returns (address)
    {
        do_something;
    }

    function thisFunctionNameIsReallyLong(address x, address y, address z)
        public
        onlyowner
        priced
        returns (address) {
        do_something;
    }

Для функций-конструкторов унаследованных контрактов, базовый контракт которых нуждается в аргументах, рекомендуется указывать базовые конструкторы на отдельных строках в той же манере, что и модификаторы, если объявление функции слишком длинно или трудно для чтения.

Да::

    contract A is B, C, D {
        function A(uint param1, uint param2, uint param3, uint param4, uint param5)
            B(param1)
            C(param2, param3)
            D(param4)
        {
            // какие-то действия с param5
        }
    }

Нет::

    contract A is B, C, D {
        function A(uint param1, uint param2, uint param3, uint param4, uint param5)
        B(param1)
        C(param2, param3)
        D(param4)
        {
            // какие-то действия с param5
        }
    }

    contract A is B, C, D {
        function A(uint param1, uint param2, uint param3, uint param4, uint param5)
            B(param1)
            C(param2, param3)
            D(param4) {
            // какие-то действия с param5
        }
    }


Эти принципы объявления функций призваны сделать код более удобочитаемым. Авторам следует использовать best judgement, поскольку это руководство не пытается охватить все возможные пермутации объявлений функций.

Отображения
========

TODO

Объявления переменных
=====================

Объявления переменных-массивов следует вводить без пробела между типом и квадратными скобками.

Да: `uint[] x;`
Нет:  `uint [] x;`

Другие рекомендации
=====================

* Заключайте операторы в одинарные пробелы с обеих сторон.

Да::

    x = 3;
    x = 100 / 10;
    x += 3 + 4;
    x |= y && z;

Нет::

    x=3;
    x = 100/10;
    x += 3+4;
    x |= y&&z;

* Операторы с более высоким приоритетом, чем у остальных, могут исключать окружающее пустое место для обозначения приоритета. Это делается, чтобы улучшить чтение сложных операторов. Вам всегда следует использовать одинаковый объем пустого места с обеих сторон оператора:

Да::

    x = 2**3 + 5;
    x = 2*y + 3*z;
    x = (a+b) * (a-b);

Нет::

    x = 2** 3 + 5;
    x = y+z;
    x +=1;


******************
Конвенции именования
******************

Конвенции именования - мощное средство, если оно принято и широко используется. Использование разных конвенций может доносить значимую *мета*-информацию, которая в противном случае не является немедленно доступной.

Рекомендации по именованию, приведенные здесь, призваны облегчить чтение, так что это не правила, а рекомендации, которые направлены на донесение большего объема информации с помощью имен.

Наконец, согласованность в пределах базы кода всегда должна ставиться выше, чем любые конвенции в этом документе.


Стили именования
=============

Во избежание замешательства мы будем использовать следующие названия разных стилей именования.

* ``b`` (single lowercase letter)
* ``B`` (single uppercase letter)
* ``lowercase``
* ``lower_case_with_underscores``
* ``UPPERCASE``
* ``UPPER_CASE_WITH_UNDERSCORES``
* ``CapitalizedWords`` (or CapWords)
* ``mixedCase`` (differs from CapitalizedWords by initial lowercase character!)
* ``Capitalized_Words_With_Underscores``

.. note:: При использовании аббревиатур в CapWords делайте все буквы аббревиатуры заглавными. Таким образом, HTTPServerError лучше, чем HttpServerError.


Имена, которых следует избегать
==============

* ``l`` - Lowercase letter el
* ``O`` - Uppercase letter oh
* ``I`` - Uppercase letter eye

Никогда не используйте эти имена переменных из одной буквы. Их трудно отличить от чисел 1 и 0.


Имена контрактов и библиотек
==========================

Контракты следует называть в стиле CapWords.


События
======

События следует именовать в стиле CapWords.


Имена функций
==============

С именами функций следует использовать формат mixedCase.


Аргументы функций
==================

При написании библиотечных функций, работающих с пользовательской структурой, структура должна быть первым аргументом и всегда должна называться ``self``.


Локальные переменные и переменные состояния
=========================

Используйте стиль mixedCase.


Константы
=========

Константы следует именовать всеми заглавными буквами со знаками подчеркивания для разделения слов (например, ``MAX_BLOCKS``).


Модификаторы
=========

Модификаторы функций должны быть словами в нижнем регистре, разделенными знаками подчеркивания.


Избегание коллизий
===================

* ``single_trailing_underscore_``

Если желаемое имя конфликтует со встроенным или иначе зарезервированным именем, рекомендуется использовать эту конвенцию.


Общие рекомендации
=======================

TODO
