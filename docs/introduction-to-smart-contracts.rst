##########################
Введение в смарт-контракты
##########################

.. _simple-smart-contract:

**********************
Простой смарт-контракт
**********************

Давайте начнем с простейшего примера. Если что-то вам покажется непонятным, не беспокойтесь, ниже мы обсудим пример подробнее.

Хранилище
=========

.. Gist: a4532ce30246847b371b

::

    contract SimpleStorage {
        uint storedData;
        function set(uint x) {
            storedData = x;
        }
        function get() constant returns (uint retVal) {
            return storedData;
        }
    }

В Solidity контракт - это блок кода (функций контракта) и данных (*состояния* контракта), расположенный по конкретному адресу в блокчейне Эфириума. В строке `uint storedData;` объявляется переменная состояния `storedData` типа `uint` (беззнаковое 256-разрядное целое число). Можете представлять ее как один слот в базе данных, который можно запрашивать и изменять, вызывая функции кода, который контролирует базу данных. В Эфириуме это всегда контракт-владелец. Нам также доступны функции `set` и `get` для изменения и получения значения переменной соответственно.

Для доступа к переменной состояния префикс `this.` не требуется.

Этот контракт практически ничего не делает (благодаря инфраструктуре Эфириума). Он лишь позволяет кому угодно сохранить одно число, которое будет доступно всем в мире, без (реалистичного) способа помешать опубликовать это число. Конечно, кто угодно может просто вызвать `set` еще раз с другим значением и перезаписать ваше число, но оно все же будет храниться в истории блокчейна. Позднее мы обсудим, как задать ограничения доступа, чтобы изменить число могли только вы.

.. index:: ! subcurrency

Пример валюты
=============

В следующем контракте реализована простейшая криптовалюта, генерировать которую может только создатель контракта (но схему эмиссии можно легко изменить). Отправлять деньги может кто угодно кому угодно, и регистрироваться для этого не требуется - все, что нужно, это пара ключей Эфириума.


.. note::
    Это не лучший пример для браузерного компилятора Solidity. Если вы пробуете этот пример в `браузерном компиляторе Solidity <https://chriseth.github.io/browser-solidity>`_, изменить адрес, с которого вызываются функции, невозможно. Иначе говоря, вы всегда будете "minter", вы можете чеканить монеты и отправлять их, но вы не можете выдать себя за кого-то другого. Возможно, в будущем это изменится.

.. Gist: ad490694f3e5b3de47ab

::

    contract Coin {
        // Ключевое слово "public" означает, что эти переменные
        // доступны извне контракта.
        address public minter;
        mapping (address => uint) public balances;

        // Благодаря событиям облегченные клиенты могут
        // эффективно реагировать на изменения.
        event Sent(address from, address to, uint amount);

        // Это конструктор, код которого выполняется только
        // при создании контракта.
        function Coin() {
            minter = msg.sender;
        }
        function mint(address receiver, uint amount) {
            if (msg.sender != minter) return;
            balances[receiver] += amount;
        }
        function send(address receiver, uint amount) {
            if (balances[msg.sender] < amount) return;
            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            Sent(msg.sender, receiver, amount);
        }
    }

В этом контракте представлены кое-какие новые концепции, давайте разберем по очереди.

В строке `address public minter;` объявляется переменная состояния, которая имеет тип address и доступна всем. `address` - это 160-разрядное значение, которое не поддерживает никакие арифметические операции. Оно подходит для хранения адресов контрактов или пар ключей. Если указано ключевое слово `public`, автоматически генерируется функция доступа к текущему значению переменной состояния. Если бы оно не было указано, изменять переменную мог бы только код этого контракта. Функция доступа выглядит как-то так::

    function minter() returns (address) { return minter; }

Конечно, добавлять эту функцию не нужно - компилятор создает ее сам.

.. index:: mapping

В строке `mapping (address => uint) public balances;` также создается общедоступная переменная состояния, но она имеет более сложный тип, который представляет собой отображение адресов на беззнаковые целые числа. Отображения можно рассматривать как хеш-таблицы, которые инициализируются всеми возможными ключами, которые отображаются на значения, байтовое представление которых содержит только нули. Однако это лишь отдаленная аналогия, потому что вы не можете получить ни список всех ключей отображения, ни список всех его значений. Так что или запоминайте (или, лучше, ведите список или используйте более продвинутый тип данных), что вы добавили в отображение, или используйте его в контексте, где это не требуется, как здесь. Функция-аксессор, созданная ключевым словом `public`, в этот раз немного сложнее и выглядит примерно так::

    function balances(address _account) returns (uint balance) {
        return balances[_account];
    }

Как видите, с ее помощью можно легко запросить баланс одного счета.

.. index:: event

В строке `event Sent(address from, address to, uint value);` объявляется так называемое "событие", которое генерируется в последней строке функции `send`. Такие сообщения, генерируемые на блокчейне, можно легко прослушивать в пользовательском интерфейсе и не только. Вместе с событием слушатель также получает аргументы `from`, `to` и `value`, которые позволяют отслеживать транзакции. Для прослушивания события можно использовать такой код::

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    }

Обратите внимание на то, как в пользовательском интерфейсе вызывается автоматически сгенерированная функция `balances`.

.. index:: coin

Специальная функция `Coin` - это конструктор, который выполняется при создании контракта и не может быть вызван после этого. В нашем случае в нем сохраняется адрес создателя контракта.  `msg` (вместе с `tx` и `block`) - это магическая глобальная переменная, которая содержит несколько свойств для доступа к блокчейну, и свойство `msg.sender` всегда содержит адрес, откуда поступил текущий (внешний) вызов функции.

Наконец, функции `mint` и `send` попадают в реальный контракт, и их могут вызывать пользователи и друге контракты. Если функцию `mint` вызывает кто-то, кроме создателя контракта, ничего не происходит. С помощью функции `send` любой пользователь (у кого уже есть монеты) может отправить монеты кому-то другому. Однако если вы используете этот контракт для отправки монет, то при просмотре адреса получателя в блокчейн-эксплорере вы не обнаружите никакой транзакции, потому что измененные балансы сохраняются только в хранилище этого конкретного контракта coin. Используя события, несложно создать "блокчейн-эксплорер", отслеживающий транзакции с вашей новой монетой.

.. _blockchain-basics:

*****************************
Основные сведения о блокчейне
*****************************

Программистам понять идею блокчейна несложно. Большинство связанных с блокчейном вычислений (майнинг, хеширование, криптография на эллиптических кривых, пиринговые сети, ...) просто предоставляют определенный набор возможностей и гарантий. Как только вы принимаете эти возможности как данность, беспокоиться о деталях реализации не требуется. Вам ведь не нужно знать, как работают веб-службы Amazon, чтобы использовать их?

.. index:: transaction

Транзакции
==========

Блокчейн - это глобальная общедоступная транзакционная база данных. Это означает, что любой может читать записи в базе данных, просто участвуя в сети. Если вы хотите изменить что-то в базе данных, вы должны создать так называемую транзакцию, которая должна быть принята всеми остальными.

Слово "транзакция" предполагает, что изменение, которое вы хотите выполнить (например, изменить два значения одновременно) или не выполняются совсем, или выполняются полностью. Более того, поа ваша транзакция применяется к базе данных, никакая другая транзакция не может изменить базу данных.

Представьте, например, таблицу с балансами всех счетов в электронной валюте. Если запрашивается траснфер с одного счета на другой, транзакционная природа базы данных гарантирует, что, если один объем вычитается с одного счета, он всегда добавляется к другому счету. Если по какой-либо причине добавление этой суммы на целевой счет невозможно, исходный счет также не изменяется.

Более того, транзакция всегда подписывается криптографической подписью отправителя (создателя). Это позволяет легко контролировать доступ к специфическим модификациям базы данных. В примере с электронной валютой простая проверка гарантирует, что только владелец ключей к счету может переводить деньги с него.

.. index:: ! block

Блоки
=====

Одним крупным препятствием, которое нужно преодолеть, является то, что в терминах Биткойна называется "атакой двойной траты": что произойдет, если в сети существуют две транзакции, которые обе хотят опустошить счет, вызывая так называемый конфликт,

Абстрактный ответ на это таков, что вы не обязаны беспокоиться. Порядок транзакций будет выбран для вас, транзакции будут упакованы в так называемый "блок", а затем будут выполнены и распространены между всеми участвующими узлами. Если две транзакции противоречат друг другу, та, что оказывается второй, отвергается и не становится частью блока.

Эти блоки формируют линейную последовательность во времени, и оттого взято слово "блокчейн" ("цепь блоков"). Блоки добавляются в цепь более-менее регулярно - для Эфириума интервал составляет около 17 секунд.

При рабте "механизма выбора порядка" (который называется "майнинг") может случиться так, что блоки иногда обращаются, но только на конце цепи. Чем больше блоков надо обратить, тем ниже вероятность, что это произойдет. Таким образом, теоретически ваши транзакции могут быть обращены и даже удалены с блокчейна, но чем больше проходит времени, тем менее это вероятно.


.. _the-ethereum-virtual-machine:

.. index:: !evm, ! ethereum virtual machine

***************************
Виртуальная машина Эфириума
***************************

Обзор
=====

Виртуальная машина Эфириума (Ethereum Virtual Machine, EVM) - это исполняющая среда для смарт-контрактов в Эфириуме. Она не только sandboxed, но на самом деле полносью изолирована, что означает, что у кода, выполняемого внутри EVM, нет доступа к сети, файловой системе или другим процессам. У смарт-контрактов даже ограничен доступ к другим смарт-контрактам.

.. index:: ! account, address, storage, balance

Учетные записи
==============

В Эфириуме есть два типа учетных записей, которые разделяют одно адресное пространство: **внешние счета**, которые контролируются парами открытого и закрытого ключей (т. е. людьми) и **счета контрактов", которые контролирует код, хранящийся вместе со счетом.

Адрес внешней учетной записи определяется по открытому ключу, тогда как адрес контракта определяется во время создания контракта (он является производным от адреса создателя и количества транзакций, отправленных с этого адреса, так называемого "nonce").

Кроме факта, хранит ли учетная запись код или нет, EVM обращается с двумя типами счетов одинаково.

Каждая учетная запись имеет персистентное **хранилище** ключей-значений, отображающее 256-разрядные слова на 256-разрядные слова.

Более того, у каждого счета есть **баланс** в эфире (в "Wei", если говорить точно), который можно изменять, отправляя транзакции с эфиром.

.. index:: ! transaction

Транзакции
==========

Транзакция - это сообщение, отправляемое с одного счета другому (который может быть тем же или специальным нулевым счетом; см. ниже). Она может включать двоичные данные (ее payload) и эфир.

Если целевой счет содержит код, этот код выполняется и полезная нагрузка предоставляется как входные данные.

Если целевой счет является нулевым (счет с адресом `0`), транзакция создает **новый контракт**. Как уже было сказано, адрес этого контракта - не нулевой адрес, а адрс, выведенный из отправителя и его количества отправленных транзакций ("nonce"). Полезная нагрузка такой транзакции создания контракта принимается за байт-код EVM и выполняется, а вывод перманентно сохраняется как код контракта. Это означает, что для создания контракта вы отправляете не фактический код контракта, но на самом деле код, который возвращает этот код.

.. index:: ! gas, ! gas price

Газ
===

При создании каждая транзакция получает счет на определенный объем **газа**, который нужен для ограничения объема работы, который нужен для выполенния транзакции и платы за это выполнение. Пока EVM выполняет транзакцию, газ постепенно расходуется согласно установленным правилам.

**Цена газа** - это значение, задаваемое создателем транзакции, который должен заблаговременно заплатить с отправляющего счета `gas_price * gas`. Если после выполнения остается некоторый газ, он таким же образом возвращается.

Если газ в какой-либо момент исчерпывается (т. е. становится отрицательным), генерируется исключение out-of-gas, которое образает все изменения, внесенные в состояние в текущем фрейме стека.

.. index:: ! storage, ! memory, ! stack

Хранилище, память и стек
========================

У каждого счета есть персистентная область памяти, которая называется **хранилище**. Хранилище - это хранилище ключей-значений, которое отображает 256-разрядные слова на 256-разрядные слова. Перечислить хранилище изнутри контракта невозможно, и сравнительно дорого читать и еще более дорого изменять хранилище. Контракт может читать и писать только собственное хранилище.

Вторая область памяти называется **память**, свеже очищенный экземпляр которой контракт получает для каждого вызова сообщения. Память может адресоваться на уровне байтов, но читается и записывается она "чанками" по 32 байта (256 бит). Память становится дороже по мере роста (она масштабируется квадратично).

EVM - это не регистровая машина, а стековая, так что все вычисления выполняются в области, которая называется **стек**. Он имеет максимальный размер 1024 элемента и содержит слова из 256 бит. Доступ к стеку ограничен верхним концом следующим образом: можно копировать один из верхних 16 элементов на вершину  стека или поменять местами верхний элемент с одним из 16 элементов под ним. Все другие операции берут два (или один или больше в зависимости от операции) элемента из стека и помещают результат в стек. Конечно, можно перемещать элементы стека в хранилище или память, но невозможно получить доступ к произвольным элементам глубже в стеке, не удалив сначала вершину стека.

.. index:: ! instruction

Набор инструкций
================

Набор инструкций EVM держится минимальным во избежание некорректных реализаций, которые могут привести к проблемам с консенсусом. Все инструкции рабтают с базовым типом данных, 256-разрядными словами. Имеются обычные арифметические, поразрядные, логические операции и операции сравнения. Возможны условные и безусловные переходы. Более того, контракты могут получать доступ к релевантным свойствам текущего блока, таким как его номер и временная метка.

.. index:: ! message call, function;call

Вызовы сообщений
================

Контракты могут вызывать другие контракты и даже отправлять эфир счетам неконтрактов с помощью вызовов сообщений. Вызовы сообщений похожи на транзакции в том, что они имеют источник, цель, полезную нагрузку в виде данных, эфир, газ и возвращаемые данные. Фактически, каждая транзакция состоит из вызова сообщения верхнего уровня, которое, в свою очередь, может создавать дальнейшие вызовы сообщений.

Контракт может решить, сколько из оставшегося **газа** следует потправить с внутренним вызовом сообщения и сколько он хочет сохранить. Если во внуреннем вызове происходит исключение завершеня газа (или любое другое), об этом просигнализирует значение ошибки, помещенное в стека. В этом случае расходуется только газ, отправленный вместе с вызовом. В Solidity вызывающий контракт приводит по умолчанию в таких ситуациях к ручному исключению, чтобы исключения "всплывали" по стеку вызовов.

Как уже было сказано, вызванный контракт (который может быть тем же, что и вызвавший) получит свеже очищенный экземпляр памяти и будет иметь доступ к полезной нагрузке вызова - которая будет предоставлена в отдельной области, называемой **calldata**. После того как он завершит выполнение, он может возвратить данные, которые будут сохранены в расположении в памяти вызывающего, предварительно выделенной вызывающим.

Вызовы **ограничены** глубиной 1024, что означает, что для более сложных операций циклы следует предпочитать рекурсивным вызовам.

.. index:: callcode, library

Callcode и библиотеки
=====================

Существует специальный вариант вызова сообщения, который называется **callcode**, который идентичен вызову сообщения, если не считать факт, что код по целевому адресу выполняется в контексте вызывающего контракта.

Это означает, что контракт может динамически загружать код с другого адреса во время выполнения. Хранилище, текущий адрес и баланс по-прежнему ссылаются на вызывающий контракт, только код берется с вызванного адреса.

Это позволяет реализовать в Solidity "библиотеку": повторно используемый библиотечный код, который можно было бы применять в хранилище контракта для реализации, например, сложной структуры данных.

.. index:: log

Журнал
======

Можно хранить данные в специально индексируемой структуре данных, которая отображает все вплоть до уровня блока. Эта возможность называется **журналы** и используется в Solidity для реализации **событий**. Контракты не могут получать доступ к данным журналов после их создания, но к ним можно получать эффективный доступ извне блокчейна. Поскольку некоторая часть данных журнала хранится в bloom filters, можно искать эти данные эффективно и криптографически безопасно, так что сетевые пиры, которые не загружают весь блокчейн ("облегченные" клиенты) все же могут находить эти журналы.

.. index:: contract creation

Создание
========

Контракты могут даже создавать другие контракты, используя специальный опкод (т. е. они не просто вызывают нулевой адрес). Единственное различие между этими **вызовами create** и обычными вызовами сообщений в том, что полезная нагрузка выполняется, а результат сохраняется как код, и вызывающий / создатель получает адрес нового контракта в стеке.

.. index:: selfdestruct

Самоуничтожение
===============

Единственная возможность удаления кода с блокчейна имеет место, когда контракт по этому адресу выполняет операцию `SELFDESTRUCT`. Оставшийся эфир, хранящийся по этому адресу, при этом отправляется указанной цели, а затем хранилище и код удаляются.

Обратите внимание, что, даже если код контракта не содержит опкод `SELFDESTRUCT`, он все же может выполнить эту операцию с помощью callcode.
