######
Разное
######

.. index:: storage, state variable, mapping

*********************************************
Расположение переменных состояния в хранилище
*********************************************

Переменные статического размера (все, за исключением отображений и динамически изменяемых массивов) располагается в хранилище непрерывно, начиная с позиции `0`. Множественные элементы, которым нужно меньше 32 байтов, упаковываются по возможности в один слот хранилища согласно следующим правилам:

- Первый элемент в слоте хранилища хранится с выровненным slot is stored lower-order aligned.
- Элементарные типы используют лишь столько байтов, сколько необходимо для их хранения.
- Если элементарный тип не помещается в оставшуюся часть слота хранилища, он перемещается в следующий слот хранилища.
- Структуры и массивы всегда начинают новый слот и занимают целые слоты (но элементы в структуре или массиве упаковываются плотно сокгласно приведенным правилам).

Элементы структур и массивов хранятся друг за другом, как если бы они были предоставлены явно.

Из-за непредсказуемого размера отображения и динамические массивы используют алгоритм `sha3` для нахождения стартовой позиции значения или данных массива. Эти начальные позиции всегда соответствуют полным слотам стека.

Отображение или динамический массив сами по себе занимают (незаполненный) слот в хранилище в некоторой позиции `p` согласно приведенному выше правилу (или путем рекурсивного применения этого правила для отображений на отображения или массивов массивов). В случае динамического массива в этом слоте хранится количество элементов в массве (байтовые массивы и строки являются здесь исключением; см. ниже). В случае отображения слот не используется (но он необходим, чтобы два равных отображения одно после другого использовали разное распределение хешей).

Данные массива располагаются по `sha3(p)`, а значение, соответствующее ключу отображения `k`, располагается по `sha3(k . p)`, где `.` представляет конкатенацию. Если значение снова является неэлементарным типом, позиции находятся путем добавления смещения `sha3(k . p)`.

`bytes` и `string` хранят свои данные в том же слоте, где также хранится длина, если они коротки. В частности: если данные занимают не больше `31` байта, они хранятся в старших байтах (выровненных по левому краю), а младший байт хранит `length * 2`. Если данные длиннее, главный слот хранит `length * 2 + 1`, а данные хранятся обычным образом в `sha3(slot)`.

Таким образом, для следующего фрагмента контракта::

    contract c {
      struct S { uint a; uint b; }
      uint x;
      mapping(uint => mapping(uint => S)) data;
    }

Позицией `data[4][9].b` является `sha3(uint256(9) . sha3(uint256(4) . uint256(1))) + 1`.

*************************
Эзотерические возможности
*************************

В системе типов Solidity есть несколько типов, у которых нет аналога в синтаксисе. Один из таких типов - типы функций. Но все же, используя `var`, можно иметь локальные переменные этих типов::

    contract FunctionSelector {
      function select(bool useB, uint x) returns (uint z) {
        var f = a;
        if (useB) f = b;
        return f(x);
      }
      function a(uint x) returns (uint z) {
        return x * x;
      }
      function b(uint x) returns (uint z) {
        return 2 * x;
      }
    }

Вызов `select(false, x)` вычислит `x * x`, а `select(true, x)` вычислит `2 * x`.

.. index:: optimizer, common subexpression elimination, constant propagation

**************************
Внутренности - оптимизатор
**************************

Оптимизатор Solidity работает с ассемблерным кодом, так что он может использоваться и используется другими языками. Он разделяет последовательность инструкций на базовые блоки, такие как JUMPs и JUMPDESTs. Внутри этих блоков инструкции анализируются, и каждое изменение стека, памяти или хранилища записывается как выражение, которое состоит из инструкции и списка аргументов, которые, по сути, являются указателями на другие выражения. Главная идея теперь - найти выражения, которые всегда равны (при каждом вводе) и объединить их в класс выражения. Оптимизатор сначала пытается найти каждое новое выражение в списке уже известных выражений. Если это не работает, выражение упрощается согласно правилам вроде `constant` + `constant` = `sum_of_constants` или `X` * 1 = `X`. Поскольку это выполняется рекурсивно, мы можем также применить последнее правило, если вторым множителем factor? является более сложное выражение, где мы знаем, что оно всегда оценивается в 1. Изменения расположений в хранилище и памяти должны стирать знания о расположениях в хранилище и памяти, о которых неизвестно, что они отличаются: если мы сначала выполняем запись в расположение x, а затем в расположение y, и оба являются входными переменными, вторая может перезаписать первую, так что на самом деле мы не знаем, что хранится у x после того как мы выполнили запись в y. С другой стороны, если упрощение выражения x - y оценивается в ненулевую константу, мы знаем, что сохраняем знание о том, что хранится at x.

В конце этого процесса мы знаем, какие выражения должны быть на стеке в конце и имеем список изменений памяти и хранилища. Эта информация хранится вместе с базовыми блоками и используется для их связи. Более того, знание о конфигурации стека, хранилища и памяти переправляются следующему блоку(ам). Если нам известны цели всех инструкций JUMP и JUMPI, мы можем построить полный граф потока управления программы. Если есть только одна цель, которую мы не знаем (это возможно, потому что, в принципе, цели переходов могут быть вычислены по входам), мы должны очистить все знание о входном состоянии блока, поскольку это может быть целью неизвестного JUMP. Если обнаруживается JUMPI, чье условие оценивается в константу, оно преобразуется в безусловный переход.

Напоследок код в каждом блоке полностью регенерируется. Граф зависимостей создается из выражений в стеке в конце блока, и каждая операция, которая не является частью этого графа, по сути, отбрасывается. Теперь генерируется код, который применяет изменения памяти и хранилища в том порядке, в котором они были сделаны в оригинальном коде (отбрасывая изменения, которые были признаны ненужными), и, наконец, генерирует все значения, которые требуются на стеке, в правильном месте.

Эти действия выполняются для каджого базового блока, и новый сгенерированный код используется как замена, если он меньше. Если базовый блок разделяется у JUMPI и во время анализа условие вычисляется в константу, JUMPI заменяется в зависимости от значения константы. Таким образом, код вроде

::

    var x = 7;
    data[7] = 9;
    if (data[x] != x + 2)
      return 2;
    else
      return 1;

упрощается до кода, который также может быть скомпилирован из этого фрагмента

::

    data[7] = 9;
    return 1;

несмотря на то, что инструкции содержали переход в начале.

.. index:: ! commandline compiler, compiler;commandline, ! solc, ! linker

*********************************************
Использование компилятора из командной строки
*********************************************

Одной из целей сборки в репозитории Solidity является `solc`, компилятор Solidity командной строки. Введя команду `solc --help`, можно увидеть описание всех параметров. Компилятор может генерировать вывод в разных форматах: от простых двоичных файлов и ассемблера по абстрактному синтаксическому дереву (parse tree) до оценок использования газа.

Если вы хотите скомпилировать только один файл, запустите компилятор как `solc --bin sourceFile.sol` и он напечатает двоичный файл. Прежде чем развертывать контракт, активируйте оптимизацию при компиляции: `solc --optimize --bin sourceFile.sol`. Если вы хотите получить некоторые более продвинутые вырианты вывода `solc`, вероятно, лучше сказать ему выводить все в отдельные файлы с помощью команды `solc -o outputDirectory --bin --ast --asm sourceFile.sol`.

Компилятор командной строки автоматически прочитает импортированные файлы из файловой системы, но также можно перенаправить путь с помощью параметра `prefix=path` следующим образом:

    solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol

По сути, это предписывает компилятору искать все, начиная с `github.com/ethereum/dapp-bin/` в разделе `/usr/local/lib/dapp-bin`, и если он не найдет файл там, он будет смотреть в `/usr/local/lib/fallback` (пустой префикс всегда дает соответствие). `solc` не будет читать файлы из файловой системы, находящиеся вне remapping targets и вне каталогов, где находятся явно указанные исходные файлы, так что команды вроде `import "/etc/passwd";` работают, только если вы добавляете `=/` как remapping.

Если из-за remappings есть несколько соответствий, выбирается соответствие с длиннейшим общим префиксом.

Если ваши контракты используют [libraries](#libraries), вы заметите, что байт-код содержит подстроки формата `__LibraryName______`. Вы можете использоваться `solc` как компоновщик, что означает, что он вставит библиотечные адреса для вас в этих точках:

Или добавьте в свою команду `--libraries "Math:0x12345678901234567890 Heap:0xabcdef0123456"`, чтобы предоставить адрес для каждой библиотеки или сохранить строку в файле (одна библиотека на строку) и запустите `solc`, используя `--libraries fileName`.

Если `solc` вызывается с параметром `--link`, все входные файлы интерпретируются как нескомпонованные двоичные файлы (в шестнадцатеричной кодировке) в приведенном выше формате `__LibraryName____` и компонуются на месте (если вход читается из stdin, он записывается в stdout). В этом случае все параметры, кроме `--libraries` (включая `-o`) игнорируются.

*****************
Советы и хитрости
*****************

* Используйте `delete` с массивами для удаления всех их элементов.
* Используйте более короткие типы с элементами структур и сортируйте их так, чтобы короткие типы группировались вместе. Это может снизить расходы на газ, потому что несколько операций SSTORE могут быть объединены в одну (SSTORE стоит 5000 или 20000 газа, так что вы хотите это оптимизировать). Используйте для проверки средство оценки стоимости газа (с включенным оптимизатором)!
* Делайте свои переменные состояния public - тогда компилятор бесплатно создаст для вас :ref:`getters <visibility-and-accessors>`.
* Если вы лосите себя на том, что много проверяете условия входных данных или состояния в начале функций, попробуйте использовать :ref:`modifiers`.
* Если ваш контракт имеет функцию под названием `send`, но вы хотите использовать встроенную функцию send, используйте код `address(contractVariable).send(amount)`.
* Если вы **не** хотите, чтобы ваши контракты получали эфир, будучи вызванными с помощью `send`, вы можете добавить throwing fallback функцию `function() { throw; }`.
* Инициализируйте структуры в хранилище одной операцией присваивания: `x = MyStruct({a: 1, b: 2});`

*******
Ловушки
*******

К сожалению, есть некоторые тонкости, о компилятор пока еще не предупреждает.

- В коде `for (var i = 0; i < arrayName.length; i++) { ... }` типом `i` будет `uint8`, потому что это наименьший тип, который требуется для хранения значения `0`. Если массив содержит более 255 элементов, этот цикл не завершится.

*********
Шпаргалка
*********

.. index:: block, coinbase, difficulty, number, block;number, timestamp, block;timestamp, msg, data, gas, sender, value, now, gas price, origin, sha3, ripemd160, sha256, ecrecover, addmod, mulmod, cryptography, this, super, selfdestruct, balance, send

Глобальные переменные
=====================

- `block.coinbase` (`address`): адрес майнера текущего блока
- `block.difficulty` (`uint`): сложность текущего блока
- `block.gaslimit` (`uint`): ограничение газа в текущем блоке
- `block.number` (`uint`): номер текущего блока
- `block.blockhash` (`function(uint) returns (bytes32)`): хеш указанного блока - работает только для 256 последних блоков
- `block.timestamp` (`uint`): временная метка текущего блока
- `msg.data` (`bytes`): полный calldata
- `msg.gas` (`uint`): оставшийся газ
- `msg.sender` (`address`): отправитель сообщения (текущий вызов)
- `msg.value` (`uint`): количество wei, отправленное с сообщением
- `now` (`uint`): временная метка текущего блока (псевдоним для `block.timestamp`)
- `tx.gasprice` (`uint`): цена газа транзакции
- `tx.origin` (`address`): отправитель транзакции (полная цепь вызовов)
- `sha3(...) returns (bytes32)`: вычисляет хеш Ethereum-SHA3 (плотно упакованных) аргументов
- `sha256(...) returns (bytes32)`: вычисляет хеш SHA256 (плотно упакованных) аргументов
- `ripemd160(...) returns (bytes20)`: вычисляет RIPEMD от 256 (плотно упакованных) аргументов
- `ecrecover(bytes32, uint8, bytes32, bytes32) returns (address)`: восстанавливает открытый ключ из сигнатуры эллиптической кривой
- `addmod(uint x, uint y, uint k) returns (uint)`: вычисляет `(x + y) % k`, где сложение выполняется с произвольной точностью и не wrap around при `2**256`.
- `mulmod(uint x, uint y, uint k) returns (uint)`: вычисляет `(x * y) % k`, где умножение выполняется с произвольной точностью и не wrap around при `2**256`.
- `this` (тип текущего контракта): текущий контракт, который можно явно преобразовать в `address`
- `super`: контракт на один уровень выше в иерархии наследования
- `selfdestruct(address)`: уничтожает текущий контракт, отправляя его фонды по указанному адресу
- `<address>.balance`: баланс адреса в Wei
- `<address>.send(uint256) returns (bool)`: отправляет указанное количество Wei по адресу; при сбое возвращает `false`.

.. index:: visibility, public, private, external, internal

Спецификаторы видимости функций
===============================

::

    function myFunction() <visibility specifier> returns (bool) {
        return true;
    }

- `public`: видима внешне и внутренне (создает функцию-аксессор для переменных в хранилище/переменных состояния)
- `private`: видима только в текущем контракте
- `external`: видима только внешне (только для функций), т. е. может быть вызвана только путем вызова сообщения (посредством `this.fun`)
- `internal`: видима только внутренне


.. index:: modifiers, constant, anonymous, indexed

Модификаторы
============

- `constant` для переменных состояния: запрещает присваивание (за исключением инициализации), не занимает слот хранилища.
- `constant` для функций: запрещает изменение состояния - это еще не обеспечивается.
- `anonymous` для событий: не сохраняет сигнатуру события как тему-?.
- `indexed` для параметров событий: сохраняет параметр как topic.

